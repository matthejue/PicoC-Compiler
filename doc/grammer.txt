*******************************************************************************
*                        Statement Sequences (code_ss)                        *
*******************************************************************************

ss = <s> ; <ss>
ss = <emptyword>
s = <code_a>
s = <code_cs>
s = <code_ls>

*******************************************************************************
*                Allocation / Assignment Expressions (code_aa)                *
*******************************************************************************

va   : <v> = <va>
va   : <v> = <e>
init : <t> <va>
init : <t> <v>
init : const <t> <va>

*******************************************************************************
*                      Arithmetic Expressions (code_ae) - Lecture             *
*******************************************************************************

e     : <vi>
e     : <ci>
e     : <c>
e     : <e> <binop> <e>
e     : <unop> <e>
binop : '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^'
unop  : '-' | '~'

*******************************************************************************
*                 Arithmetic Expressions (coade_ae) - Extented                *
*******************************************************************************

prec2        : <prec1> <binops_prec2> <prec2> | <prec1>
prec1        : <ao> <binops_prec1> <prec1> | <ao>
ao           : <unops> <ao>
ao           : <v>
ao           : <c>
ao           : <ci>
ao           : '(' <prec2> ')'
c            : <number>  // value provied by lexer
binops_prec2 : '+' | '-'
binops_prec1 : '*' | '/' | '%'
unops        : '-' | '~'

** implemented by lexer: **
number                  : <digit_with_zero> <digit_without_zero>
digit_with_zero         : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
digit_without_zero      : <digit_without_zero> <digit_without_zero> | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

** still has to be implemented: **
binop_prec3 : '&' | '|' | '^'

**************************************************************************
*                             Grammer translation                        *
**************************************************************************

if ( «lookahead-predicts-alt1» ) {
  «match-alt1»
} else if ( «lookahead-predicts-alt2» ) {
  «match-alt2»
} else if ( «lookahead-predicts-altN» ) {
  «match-altN»
} else «throw-exception» // parse error (no viable alternative)

if ( «lookahead-is-T» ) {
  match(T);
} // no error else clause

savestate_node = down(classname, token)
while ( «lookahead-predicts-an-alt-of-subrule» ) {
  «code-matching-alternatives»
  down(classname, token)
}
up(savestate_node)


savestate_node = down(classname, token)
do {
  «code-matching-alternatives»
  up(savestate_node)
} while ( «lookahead-predicts-an-alt-of-subrule» );
