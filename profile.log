FUNCTION  <SNR>61_unc_path()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 3 times
Total time:   0.000129
 Self time:   0.000020

count  total (s)   self (s)
    3   0.000127   0.000019   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 10 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
   10              0.000064   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
   10              0.000005   endif

FUNCTION  <SNR>160_get_syn()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 2204 times
Total time:   0.034273
 Self time:   0.034273

count  total (s)   self (s)
 2204              0.001817     let color = ''
 2204              0.005809     if hlexists(a:group)
 2116              0.008308       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 2204              0.000844     endif
 2204              0.003168     if empty(color) || color == -1
                                  " should always exist
   88              0.001199       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
   88              0.000141       if empty(color) || color == -1
                                    let color = 'NONE'
   88              0.000036       endif
 2204              0.000691     endif
 2204              0.001652     return color

FUNCTION  <SNR>59_Slash()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:465
Called 820 times
Total time:   0.001374
 Self time:   0.001374

count  total (s)   self (s)
  820              0.001159     return a:path

FUNCTION  coc#client#get_channel()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim:149
Called 177 times
Total time:   0.000923
 Self time:   0.000923

count  total (s)   self (s)
  177              0.000203   if s:is_vim
                                return a:client['channel']
  177              0.000071   endif
  177              0.000275   return a:client['chan_id']

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:93
Called 13 times
Total time:   0.008842
 Self time:   0.000999

count  total (s)   self (s)
   91              0.000095     for Fn in a:list
   91   0.008526   0.000683       let code = call(Fn, a:000)
   91              0.000074       if code != 0
   13              0.000011         return code
   78              0.000024       endif
   78              0.000030     endfor
                                return 0

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 6 times
Total time:   0.021675
 Self time:   0.000613

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    6   0.001686   0.000052   if gitgutter#utility#is_active(a:bufnr)
                            
    6              0.000039     if has('patch-7.4.1559')
    6              0.000051       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    6              0.000004     endif
    6   0.000373   0.000061     let how = s:setup_path(a:bufnr, l:Callback)
    6              0.000018     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
    6              0.000003     endif
                            
    6   0.000118   0.000042     if a:force || s:has_fresh_changes(a:bufnr)
                            
    3              0.000003       let diff = 'NOT SET'
    3              0.000003       try
    3   0.019125   0.000087         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    3              0.000003       endtry
                            
    3              0.000011       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    3              0.000001       endif
                            
    6              0.000003     endif
    6              0.000003   endif

FUNCTION  <SNR>200_build_command()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000005   if has('unix')
    3              0.000005     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>164_ModifierFlags()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:11
Called 272 times
Total time:   0.001015
 Self time:   0.001015

count  total (s)   self (s)
  272              0.000889   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:14
Called 272 times
Total time:   0.008900
 Self time:   0.001677

count  total (s)   self (s)
  272   0.008793   0.001571   return airline#extensions#coc#get('error')

FUNCTION  <SNR>208_process_modified()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:310
Called 6 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    6              0.000006   let offset = 0
   12              0.000014   while offset < a:to_count
    6              0.000008     let line_number = a:to_line + offset
    6              0.000014     call add(a:modifications, [line_number, 'modified'])
    6              0.000006     let offset += 1
   12              0.000007   endwhile

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 3 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    3              0.000013   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    3              0.000001   endif

FUNCTION  airline#check_mode()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline.vim:216
Called 272 times
Total time:   0.107692
 Self time:   0.032352

count  total (s)   self (s)
  272              0.000878   if !has_key(s:contexts, a:winnr)
                                return ''
  272              0.000280   endif
  272              0.000908   let context = s:contexts[a:winnr]
                            
  272              0.000677   if get(w:, 'airline_active', 1)
  272              0.000582     let m = mode(1)
  272              0.000426     if m ==# "i"
                                  let mode = ['insert']
  272              0.000469     elseif m[0] ==# "i"
                                  let mode = ['insert']
  272              0.000220     elseif m ==# "Rv"
                                  let mode =['replace']
  272              0.000241     elseif m[0] ==# "R"
                                  let mode = ['replace']
  272              0.002448     elseif m[0] =~# '\v(v|V||s|S|)'
                                  let mode = ['visual']
  272              0.000206     elseif m ==# "t"
                                  let mode = ['terminal']
  272              0.000236     elseif m[0] ==# "c"
    2              0.000004       let mode = ['commandline']
  270              0.000415     elseif m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let mode = ['normal']
  270              0.000342     elseif m[0:1] ==# 'ni'
                                  let mode = ['insert']
                                  let m = 'ni'
  270              0.000143     else
  270              0.000446       let mode = ['normal']
  272              0.000120     endif
  272   0.004143   0.002392     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
  272              0.000114     endif
  272              0.002869     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], m) == -1
  272              0.000349       let m = m[0]
  272              0.000109     endif
  272              0.001020     let w:airline_current_mode = get(g:airline_mode_map, m, m)
                              else
                                let mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
  272              0.000139   endif
                            
  272              0.000826   if g:airline_detect_modified && &modified
                                call add(mode, 'modified')
  272              0.000115   endif
                            
  272              0.000355   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
  272              0.000088   endif
                            
  272              0.002554   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
  272              0.000090   endif
                            
  272              0.000418   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
  272              0.000104   endif
                            
  272              0.000391   if &readonly || ! &modifiable
                                call add(mode, 'readonly')
  272              0.000084   endif
                            
  272              0.000821   let mode_string = join(mode)
  272              0.000803   if get(w:, 'airline_lastmode', '') != mode_string
    7   0.001850   0.000064     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    7   0.071430   0.000109     call airline#highlighter#highlight(mode, string(context.bufnr))
    7   0.000565   0.000083     call airline#util#doautocmd('AirlineModeChanged')
    7              0.000014     let w:airline_lastmode = mode_string
  272              0.000093   endif
                            
  272              0.000250   return ''

FUNCTION  <SNR>59_Tree()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:297
Called 272 times
Total time:   0.002556
 Self time:   0.002556

count  total (s)   self (s)
  272              0.000373   let dir = a:path
  272              0.001165   if dir =~# '/\.git$'
  272              0.000839     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  let wt_config = filter(copy(config),'v:val =~# "^\\s*worktree *="')
                                  if len(wt_config) == 1
                                    let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                  else
                                    call filter(config,'v:val =~# "^\\s*bare *= *false *$"')
                                    if len(config)
                                      let s:worktree_for_dir[dir] = 0
                                    endif
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  airline#util#append()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:49
Called 1904 times
Total time:   0.015076
 Self time:   0.015076

count  total (s)   self (s)
 1904              0.003461   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1904              0.000692   endif
 1904              0.004677   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1904              0.004090   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>176_add_section()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 45 times
Total time:   0.002863
 Self time:   0.001259

count  total (s)   self (s)
   45              0.000162     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   45   0.000376   0.000172     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   45              0.000015     endif
   45              0.000029     if condition
                                  call a:builder.add_raw('%(')
   45              0.000014     endif
   45   0.002012   0.000612     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   45              0.000030     if condition
                                  call a:builder.add_raw('%)')
   45              0.000023     endif

FUNCTION  airline#extensions#mundo#inactive_statusline()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-mundo/autoload/airline/extensions/mundo.vim:3
Called 7 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    7              0.000009     let builder = a:1
    7              0.000013     if getwinvar(a:2.winnr, '&filetype') == 'Mundo'
                                    return -1
    7              0.000003     endif
    7              0.000012     if getwinvar(a:2.winnr, '&filetype') == 'MundoDiff'
                                    return 1
    7              0.000002     endif

FUNCTION  <SNR>204_ReloadWinStatus()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:4170
Called 3 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    3              0.000021   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    3              0.000002     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:207
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    3              0.000012   let dt = localtime() - s:focusgained_ignore_time
    3              0.000015   let s:focusgained_ignore_time = 0
    3              0.000004   return dt >= 1

FUNCTION  <SNR>47_on_focus_gained()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/plugin/airline.vim:77
Called 3 times
Total time:   0.062536
 Self time:   0.000068

count  total (s)   self (s)
    3   0.000068   0.000025   if airline#util#try_focusgained()
    3   0.062463   0.000037     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    3              0.000001   endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/themes.vim:35
Called 206 times
Total time:   0.028873
 Self time:   0.001656

count  total (s)   self (s)
  206   0.028807   0.001590     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>202_SetStatusLine()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:3437
Called 3 times
Total time:   0.007831
 Self time:   0.000700

count  total (s)   self (s)
    3   0.000392   0.000351     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    3              0.000009     if tagbarwinnr == -1 || exists('g:tagbar_no_status_line')
                                    return
    3              0.000001     endif
                            
                                " Make sure we're actually in the Tagbar window
    3              0.000005     if tagbarwinnr != winnr()
    3              0.000004         let in_tagbar = 0
    3              0.000003         let prevwinnr = winnr()
    3   0.000245   0.000023         call s:goto_win('p', 1)
    3              0.000006         let pprevwinnr = winnr()
    3   0.000126   0.000018         call s:goto_win(tagbarwinnr, 1)
                                else
                                    let in_tagbar = 1
    3              0.000001     endif
                            
    3   0.000082   0.000018     if !empty(tagbar#state#get_current_file(0))
    3   0.000062   0.000015         let fileinfo = tagbar#state#get_current_file(0)
    3              0.000010         let fname = fnamemodify(fileinfo.fpath, ':t')
    3              0.000009         let sorted = get(fileinfo.typeinfo, 'sort', g:tagbar_sort)
                                else
                                    let fname = ''
                                    let sorted = g:tagbar_sort
    3              0.000001     endif
    3              0.000005     let sortstr = sorted ? 'Name' : 'Order'
                            
    3              0.000004     let flags = []
    3              0.000012     let flags += exists('w:autoclose') && w:autoclose ? ['c'] : []
    3              0.000005     let flags += g:tagbar_autoclose ? ['C'] : []
    3              0.000006     let flags += (sorted && g:tagbar_case_insensitive) ? ['i'] : []
    3              0.000016     let flags += g:tagbar_hide_nonpublic ? ['v'] : []
                            
    3              0.000006     if exists('g:tagbar_status_func')
    3              0.000008         let args = [in_tagbar, sortstr, fname, flags]
    3   0.006248   0.000051         let &l:statusline = call(g:tagbar_status_func, args)
                                else
                                    let colour = in_tagbar ? '%#StatusLine#' : '%#StatusLineNC#'
                                    let flagstr = join(flags, '')
                                    if flagstr !=# ''
                                        let flagstr = '[' . flagstr . '] '
                                    endif
                                    let text = colour . '[' . sortstr . '] ' . flagstr . fname
                                    let &l:statusline = text
    3              0.000001     endif
                            
    3              0.000003     if !in_tagbar
    3   0.000228   0.000026         call s:goto_win(pprevwinnr, 1)
    3   0.000280   0.000029         call s:goto_win(prevwinnr, 1)
    3              0.000002     endif

FUNCTION  FugitiveWorkTree()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:276
Called 272 times
Total time:   0.015880
 Self time:   0.003008

count  total (s)   self (s)
  272   0.015125   0.002253   let tree = s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
  272              0.000365   if tree isnot# 0 || a:0 > 1
  272              0.000218     return tree
                              else
                                return ''
                              endif

FUNCTION  <SNR>208_process_removed()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:302
Called 12 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
   12              0.000010   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
   12              0.000005   else
   12              0.000026     call add(a:modifications, [a:to_line, 'removed'])
   12              0.000005   endif

FUNCTION  <SNR>153_check_defined_section()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:47
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000012   if !exists('w:airline_section_{a:name}')
    3              0.000011     let w:airline_section_{a:name} = g:airline_section_{a:name}
    3              0.000001   endif

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 3 times
Total time:   0.000940
 Self time:   0.000697

count  total (s)   self (s)
    3              0.000006   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    3              0.000041     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    3   0.000059   0.000025     let modified_lines = s:handle_double_hunk(a:modified_lines)
    3   0.000756   0.000547     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    3              0.000006     if exists('*sign_placelist')
    3              0.000060       call sign_placelist(signs)
    3              0.000003       return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  <SNR>47_airline_refresh()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/plugin/airline.vim:216
Called 3 times
Total time:   0.062426
 Self time:   0.000435

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    3              0.000012   let fast=!empty(get(a:000, 0, 0))
    3              0.000010   if !exists("#airline")
                                " disabled
                                return
    3              0.000001   endif
    3   0.000578   0.000018   call airline#util#doautocmd('AirlineBeforeRefresh')
    3   0.000674   0.000024   call airline#highlighter#reset_hlcache()
    3              0.000003   if !fast
                                call airline#load_theme()
    3              0.000002   endif
    3   0.061084   0.000318   call airline#update_statusline()
    3   0.000047   0.000032   call airline#update_tabline()

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:10
Called 272 times
Total time:   0.010067
 Self time:   0.001812

count  total (s)   self (s)
  272   0.009925   0.001670   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:38
Called 272 times
Total time:   0.007857
 Self time:   0.002138

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
  272   0.007557   0.001839   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 544 times
Total time:   0.015879
 Self time:   0.015879

count  total (s)   self (s)
  544              0.014539   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
  544              0.000514     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  coc#float#check_related()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:865
Called 3 times
Total time:   0.001325
 Self time:   0.000279

count  total (s)   self (s)
    3              0.000009   let invalids = []
    3   0.001093   0.000046   let ids = coc#float#get_float_win_list(1)
   11              0.000016   for id in ids
    8              0.000031     let target = getwinvar(id, 'target_winid', 0)
    8              0.000041     if (target && index(ids, target) == -1) || getwinvar(id, 'kind', '') == 'pum'
                                  call add(invalids, id)
    8              0.000004     endif
   11              0.000008   endfor
    3              0.000007   if !s:popup_list_api
    3              0.000046     let s:popup_list = filter(ids, "index(invalids, v:val) == -1")
    3              0.000002   endif
    3              0.000007   for id in invalids
                                call coc#float#close(id)
    3              0.000002   endfor

FUNCTION  <SNR>208_save_last_seen_change()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:415
Called 3 times
Total time:   0.000063
 Self time:   0.000022

count  total (s)   self (s)
    3   0.000062   0.000021   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>208_process_hunk()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:240
Called 27 times
Total time:   0.003033
 Self time:   0.001393

count  total (s)   self (s)
   27              0.000031   let modifications = []
   27              0.000037   let from_line  = a:hunk[0]
   27              0.000030   let from_count = a:hunk[1]
   27              0.000028   let to_line    = a:hunk[2]
   27              0.000028   let to_count   = a:hunk[3]
                            
   27   0.000160   0.000115   if s:is_added(from_count, to_count)
    6   0.000321   0.000042     call s:process_added(modifications, from_count, to_count, to_line)
    6   0.000258   0.000037     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
   21   0.000120   0.000085   elseif s:is_removed(from_count, to_count)
   12   0.000136   0.000065     call s:process_removed(modifications, from_count, to_count, to_line)
   12   0.000472   0.000073     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    9   0.000059   0.000037   elseif s:is_modified(from_count, to_count)
    6   0.000115   0.000036     call s:process_modified(modifications, from_count, to_count, to_line)
    6   0.000254   0.000038     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    3   0.000021   0.000015   elseif s:is_modified_and_added(from_count, to_count)
    3   0.000089   0.000022     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    3   0.000126   0.000020     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    3   0.000110   0.000018     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
   27              0.000010   endif
   27              0.000025   return modifications

FUNCTION  yoink#getDefaultYankInfo()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-yoink/autoload/yoink.vim:380
Called 3 times
Total time:   0.000126
 Self time:   0.000041

count  total (s)   self (s)
    3   0.000124   0.000039     return yoink#getYankInfoForReg(yoink#getDefaultReg())

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:196
Called 3 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    3              0.000074   let p = resolve(expand('#'.a:bufnr.':p'))
    3              0.000024   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    3              0.000007   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    3              0.000002   endif
    3              0.000005   return g:gitgutter_diff_base

FUNCTION  yoink#onFocusLost()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-yoink/autoload/yoink.vim:456
Called 3 times
Total time:   0.000168
 Self time:   0.000042

count  total (s)   self (s)
    3   0.000165   0.000039     let s:focusLostInfo = yoink#getDefaultYankInfo()

FUNCTION  airline#parts#filetype()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 272 times
Total time:   0.004489
 Self time:   0.002472

count  total (s)   self (s)
  272   0.004353   0.002335   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 3 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000021   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    3              0.000001   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 272 times
Total time:   0.001483
 Self time:   0.001483

count  total (s)   self (s)
  272              0.000664   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
  272              0.000103   endif
  272              0.000178   return ''

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 298 times
Total time:   0.005575
 Self time:   0.002504

count  total (s)   self (s)
  298   0.005437   0.002366   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#update_tabline()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline.vim:290
Called 166 times
Total time:   0.000965
 Self time:   0.000965

count  total (s)   self (s)
  166              0.000428   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
  166              0.000075   endif

FUNCTION  <SNR>61_exists_file()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 6 times
Total time:   0.000574
 Self time:   0.000141

count  total (s)   self (s)
    6   0.000565   0.000132   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>61_dir()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 9 times
Total time:   0.000799
 Self time:   0.000167

count  total (s)   self (s)
    9   0.000795   0.000163   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>215_str()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/prototypes/normaltag.vim:56
Called 28 times
Total time:   0.000408
 Self time:   0.000408

count  total (s)   self (s)
   28              0.000043     if a:full && self.path !=# ''
                                    let str = self.path . self.typeinfo.sro . self.name
   28              0.000012     else
   28              0.000038         let str = self.name
   28              0.000014     endif
                            
   28              0.000052     if has_key(self.fields, 'signature')
   28              0.000021         if a:longsig
                                        let str .= self.fields.signature
   28              0.000011         else
   28              0.000043             let str .= '()'
   28              0.000010         endif
   28              0.000010     endif
                            
   28              0.000023     return str

FUNCTION  coc#float#get_related()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:1267
Called 156 times
Total time:   0.002859
 Self time:   0.002859

count  total (s)   self (s)
  156              0.001689   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
  156              0.000140   endfor
  156              0.000145   return 0

FUNCTION  <SNR>208_is_modified_and_added()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 3 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    3              0.000006   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <SNR>202_do_delayed_update()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:3590
Called 3 times
Total time:   0.000222
 Self time:   0.000105

count  total (s)   self (s)
    3   0.000151   0.000034     let curfile = tagbar#state#get_current_file(0)
    3              0.000008     if empty(curfile)
                                    let curfname = ''
    3              0.000002     else
    3              0.000009         let curfname = curfile.fpath
    3              0.000002     endif
                            
    3              0.000012     while !empty(s:delayed_update_files)
                                    let fname = remove(s:delayed_update_files, 0)
                                    let no_display = curfname !=# fname
                                    call s:AutoUpdate(fname, 1, no_display)
    3              0.000004     endwhile

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:18
Called 544 times
Total time:   0.015478
 Self time:   0.015478

count  total (s)   self (s)
  544              0.001683   if !exists(':CocCommand')
                                return ''
  544              0.000225   endif
  544              0.001400   let _backup = get(g:, 'coc_stl_format', '')
  544              0.001043   let is_err = (a:type  is# 'error')
  544              0.001331   let info = get(b:, 'coc_diagnostic_info', {})
  544              0.001614   if empty(info) | return '' | endif
                            
                            
  544              0.001147   let cnt = get(info, a:type, 0)
                            
  544              0.000650   if empty(cnt)
                                return ''
  544              0.000219   else
  544              0.002243     let lnum = printf('(L%d)', (info.lnums)[is_err ? 0 : 1])
  544              0.001790     return (is_err ? s:error_symbol : s:warning_symbol).cnt.lnum
                              endif

FUNCTION  <SNR>160_hl_group_exists()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 269 times
Total time:   0.002442
 Self time:   0.002442

count  total (s)   self (s)
  269              0.000617     if !hlexists(a:group)
                                  return 0
  269              0.001042     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
  269              0.000093     endif
  269              0.000159     return 1

FUNCTION  <SNR>206_getKind()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/prototypes/typeinfo.vim:17
Called 31 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
                                "let idx = self.kinddict[a:kind]
   31              0.000135     let idx = has_key(self.kinddict, a:kind) ? self.kinddict[a:kind] : -1
   31              0.000064     return self.kinds[idx]

FUNCTION  <SNR>208_process_modified_and_added()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:319
Called 3 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    3              0.000003   let offset = 0
    6              0.000007   while offset < a:from_count
    3              0.000004     let line_number = a:to_line + offset
    3              0.000007     call add(a:modifications, [line_number, 'modified'])
    3              0.000003     let offset += 1
    6              0.000003   endwhile
    6              0.000005   while offset < a:to_count
    3              0.000004     let line_number = a:to_line + offset
    3              0.000006     call add(a:modifications, [line_number, 'added'])
    3              0.000002     let offset += 1
    6              0.000002   endwhile

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 6 times
Total time:   0.000255
 Self time:   0.000100

count  total (s)   self (s)
    6   0.000253   0.000097   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:184
Called 48 times
Total time:   0.029429
 Self time:   0.000762

count  total (s)   self (s)
   48              0.000308     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   48   0.029098   0.000430     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  coc#cursor#position()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/cursor.vim:16
Called 19 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
   19              0.000197   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 3 times
Total time:   0.000408
 Self time:   0.000056

count  total (s)   self (s)
    3   0.000186   0.000035   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    3   0.000220   0.000019   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  tagbar#debug#log()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/debug.vim:30
Called 35 times
Total time:   0.000276
 Self time:   0.000276

count  total (s)   self (s)
   35              0.000050     if s:debug_enabled
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
   35              0.000018     endif

FUNCTION  <SNR>160_exec_separator()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 103 times
Total time:   0.056249
 Self time:   0.003774

count  total (s)   self (s)
  103              0.000140     if pumvisible()
                                  return
  103              0.000036     endif
  103              0.000264     let group = a:from.'_to_'.a:to.a:suffix
  103   0.017806   0.000699     let l:from = airline#themes#get_highlight(a:from.a:suffix)
  103   0.012439   0.000673     let l:to = airline#themes#get_highlight(a:to.a:suffix)
  103              0.000080     if a:inverse
   22              0.000073       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   81              0.000031     else
   81              0.000266       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  103              0.000036     endif
  103              0.000322     let a:dict[group] = colors
  103   0.024362   0.000760     call airline#highlighter#exec(group, colors)

FUNCTION  airline#util#winwidth()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:19
Called 3569 times
Total time:   0.024206
 Self time:   0.024206

count  total (s)   self (s)
 3569              0.007352   let nr = get(a:000, 0, 0)
 3569              0.005757   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
 3569              0.001478   else
 3569              0.004973     return winwidth(nr)
                              endif

FUNCTION  33()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 10 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
   10              0.000032   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  35()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 61 times
Total time:   0.000190
 Self time:   0.000190

count  total (s)   self (s)
   61              0.000170   call add(self._sections, [a:group, a:contents])

FUNCTION  tagbar#currenttag()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:3890
Called 28 times
Total time:   0.013997
 Self time:   0.001478

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   28              0.000056     let s:statusline_in_use = 1
                            
   28              0.000029     if a:0 >= 1
                                    " also test for non-zero value for backwards compatibility
   28              0.000150         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   28              0.000061         let fullpath  = a:1 =~# 'f'
   28              0.000052         let prototype = a:1 =~# 'p'
   28              0.000023         if a:0 >= 2
   28              0.000036             let search_method = a:2
                                    else
                                        let search_method = 'nearest-stl'
   28              0.000011         endif
                                else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                    let search_method = 'nearest-stl'
   28              0.000013     endif
                            
   28   0.000709   0.000138     if !s:Init(1)
                                    return a:default
   28              0.000009     endif
                            
   28   0.011730   0.000189     let tag = s:GetNearbyTag(search_method, 1)
                            
   28              0.000038     if !empty(tag)
   28              0.000022         if prototype
                                        return tag.getPrototype(1)
   28              0.000013         else
   28   0.000714   0.000306             return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  <SNR>177_has_fresh_changes()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:162
Called 3 times
Total time:   0.000077
 Self time:   0.000039

count  total (s)   self (s)
    3   0.000074   0.000037   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>204_DirUrlPrefix()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:498
Called 272 times
Total time:   0.013009
 Self time:   0.001859

count  total (s)   self (s)
  272   0.012908   0.001758   return 'fugitive://' . call('s:GitDir', a:000) . '//'

FUNCTION  gitgutter#async#available()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 3 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    3              0.000004   return s:available

FUNCTION  tagbar#is_paused()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:3815
Called 46 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
   46              0.000053     return s:paused

FUNCTION  40()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 13 times
Total time:   0.055813
 Self time:   0.008310

count  total (s)   self (s)
   13              0.000015   let side = 1
   13              0.000010   let line = ''
   13              0.000010   let i = 0
   13              0.000026   let length = len(self._sections)
   13              0.000010   let split = 0
   13              0.000012   let is_empty = 0
   13              0.000022   let prev_group = ''
                            
   84              0.000099   while i < length
   71              0.000129     let section = self._sections[i]
   71              0.000104     let group = section[0]
   71              0.000093     let contents = section[1]
   71              0.000080     let pgroup = prev_group
   71   0.001133   0.000495     let prev_group = airline#builder#get_prev_group(self._sections, i)
   71              0.000152     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   71              0.001194     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   71              0.000171     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   71              0.000029     endif
   71              0.000060     if is_empty
                                  let prev_group = pgroup
   71              0.000020     endif
   71   0.000919   0.000456     let is_empty = s:section_is_empty(self, contents)
                            
   71              0.000043     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   71              0.000024     endif
                            
   71              0.000066     if group == ''
                                  let line .= contents
   71              0.000065     elseif group == '|'
   10              0.000008       let side = 0
   10              0.000019       let line .= contents
   10              0.000008       let split = 1
   61              0.000024     else
   61              0.000059       if prev_group == ''
   13              0.000030         let line .= '%#'.group.'#'
   48              0.000034       elseif split
   10              0.000007         if !is_empty
   10   0.010133   0.000092           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   10              0.000005         endif
   10              0.000010         let split = 0
   38              0.000013       else
   38              0.000027         if !is_empty
   38   0.034011   0.000298           let line .= s:get_seperator(self, prev_group, group, side)
   38              0.000018         endif
   61              0.000036       endif
   61   0.003312   0.000664       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   71              0.000029     endif
                            
   71              0.000086     let i = i + 1
   84              0.000062   endwhile
                            
   13              0.000016   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   10              0.000358     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   13              0.000007   endif
   13              0.000020   return line

FUNCTION  41()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:814
Called 6 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    6              0.000024     return get(self._files, a:fname, {})

FUNCTION  43()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:830
Called 3 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    3              0.000015     return has_key(self._files, a:fname)

FUNCTION  46()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/state.vim:32
Called 46 times
Total time:   0.000364
 Self time:   0.000296

count  total (s)   self (s)
   46   0.000277   0.000209     if !tagbar#is_paused() || a:force_current
   46              0.000060         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  <SNR>175_get_seperator()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 38 times
Total time:   0.033713
 Self time:   0.000601

count  total (s)   self (s)
   38   0.012431   0.000264   if airline#builder#should_change_group(a:prev_group, a:group)
   38   0.021260   0.000315     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:38
Called 272 times
Total time:   0.012136
 Self time:   0.002000

count  total (s)   self (s)
  272   0.011992   0.001856   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 272 times
Total time:   0.008437
 Self time:   0.008437

count  total (s)   self (s)
  272              0.001519   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  272              0.000804     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
  272              0.000869     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
  272              0.000565     let default = get(g:, 'airline#extensions#keymap#default', '')
  272              0.000333     if (label !=# '')
  272              0.000612       let label .= ' '
  272              0.000135     endif
  272              0.000394     let keymap = &keymap
  272              0.000527     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
  272              0.000103     endif
  272              0.001531     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:231
Called 3 times
Total time:   0.003270
 Self time:   0.000237

count  total (s)   self (s)
    3              0.000004   let modified_lines = []
   30              0.000025   for hunk in a:hunks
   27   0.003212   0.000179     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   30              0.000014   endfor
    3              0.000003   return modified_lines

FUNCTION  airline#util#shorten()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:28
Called 1088 times
Total time:   0.024772
 Self time:   0.016096

count  total (s)   self (s)
 1088   0.015884   0.007208   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
 1088              0.000396   else
 1088              0.000972     return a:text
                              endif

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 10 times
Total time:   0.004880
 Self time:   0.000542

count  total (s)   self (s)
   10              0.000018   let winnr = a:context.winnr
   10              0.000013   let active = a:context.active
                            
   10   0.000102   0.000067   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    3   0.000671   0.000021     call s:build_sections(a:builder, a:context, s:layout[0])
    7              0.000004   else
    7   0.000546   0.000086     let text = !empty(s:get_section(winnr, 'c')) ? s:get_section(winnr, 'c') : ' %f%m '
    7   0.000074   0.000042     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   10              0.000005   endif
                            
   10   0.000404   0.000091   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   10   0.000065   0.000045   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   10   0.002897   0.000069     call s:build_sections(a:builder, a:context, s:layout[1])
   10              0.000004   endif
                            
   10              0.000008   return 1

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:189
Called 16 times
Total time:   0.000448
 Self time:   0.000316

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
   16   0.000425   0.000294   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  FugitiveVimPath()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:448
Called 272 times
Total time:   0.002121
 Self time:   0.002121

count  total (s)   self (s)
  272              0.000691   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
  272              0.000125   else
  272              0.000258     return a:path
                              endif

FUNCTION  fugitive#DidChange()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:4211
Called 3 times
Total time:   0.000205
 Self time:   0.000109

count  total (s)   self (s)
    3   0.000104   0.000035   call s:ExpireStatus(a:0 ? a:1 : -1)
    3              0.000007   if a:0 > 1 ? a:2 : (!a:0 || a:1 isnot# 0)
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
    3              0.000001   else
    3   0.000054   0.000026     call s:ReloadWinStatus()
    3              0.000002     return ''
                              endif
                              exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                              return ''

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:15
Called 272 times
Total time:   0.013888
 Self time:   0.012873

count  total (s)   self (s)
  272              0.000753   if !exists('b:fugitive_name')
    4              0.000006     let b:fugitive_name = ''
    4              0.000003     try
    4              0.000022       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    4              0.000013       elseif exists('b:git_dir') && exists('*fugitive#repo')
    4              0.000008         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
    4              0.000002         endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    4              0.000001       endif
                                catch
    4              0.000002     endtry
  272              0.000127   endif
                            
  272   0.002542   0.001527   let fmod = s:ModifierFlags()
  272              0.000396   if empty(b:fugitive_name)
  272              0.000616     if empty(bufname('%'))
                                  return &buftype ==# 'nofile' ? '[Scratch]' : '[No Name]'
  272              0.000108     endif
  272              0.003167     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  FugitiveGitDir()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:18
Called 1088 times
Total time:   0.043304
 Self time:   0.041936

count  total (s)   self (s)
 1088              0.001243   if v:version < 703
                                return ''
 1088              0.004032   elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
  272              0.000450     if exists('g:fugitive_event')
                                  return g:fugitive_event
  272              0.000115     endif
  272              0.000686     let dir = get(b:, 'git_dir', '')
  272              0.000997     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
  272              0.003450     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                  return b:git_dir
  272              0.000124     endif
  272              0.001638     return dir =~# s:bad_git_dir ? '' : dir
  816              0.001474   elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
  816              0.001264   elseif type(a:1) == type('')
  816   0.008224   0.006856     return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'git_dir', '')
                              else
                                return ''
                              endif

FUNCTION  CocActionAsync()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/plugin/coc.vim:82
Called 3 times
Total time:   0.000646
 Self time:   0.000070

count  total (s)   self (s)
    3   0.000641   0.000065   return s:AsyncRequest(a:name, a:000)

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 551 times
Total time:   0.066839
 Self time:   0.029959

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
  551              0.004779     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  551              0.001616     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  551              0.000240     else
  551   0.012285   0.002793       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  551   0.010905   0.002565       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  551   0.011010   0.002562       let guifg = s:get_syn(a:group, 'fg', 'gui')
  551   0.010345   0.002352       let guibg = s:get_syn(a:group, 'bg', 'gui')
  551              0.002032       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  551              0.000413       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  551              0.000239       else
  551   0.006305   0.003698         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  551              0.000228       endif
  551              0.000182     endif
  551              0.001420     let s:hl_groups[a:group] = res
  551              0.000385     return res

FUNCTION  yoink#getYankInfoForReg()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-yoink/autoload/yoink.vim:392
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000023     return { 'text': getreg(a:reg), 'type': getregtype(a:reg) }

FUNCTION  <SNR>163_update_branch()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:180
Called 272 times
Total time:   0.187602
 Self time:   0.012023

count  total (s)   self (s)
  816              0.001543   for vcs in keys(s:vcs_config)
  544   0.179991   0.004412     call {s:vcs_config[vcs].update_branch}()
  544              0.001813     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  544              0.000213     endif
  816              0.000530   endfor

FUNCTION  airline#extensions#tagbar#inactive_apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:24
Called 10 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   10              0.000023   if getwinvar(a:2.winnr, '&filetype') == 'tagbar'
    3              0.000002     return -1
    7              0.000003   endif

FUNCTION  airline#parts#get()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 544 times
Total time:   0.001932
 Self time:   0.001932

count  total (s)   self (s)
  544              0.001744   return get(s:parts, a:key, {})

FUNCTION  airline#util#wrap()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:42
Called 3264 times
Total time:   0.018353
 Self time:   0.015308

count  total (s)   self (s)
 3264   0.010874   0.007829   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 3264              0.001237   endif
 3264              0.002834   return a:text

FUNCTION  gitgutter#debug#log()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 6 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
    6              0.000007   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    6              0.000003   endif

FUNCTION  <SNR>204_ExpireStatus()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:4154
Called 3 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    3              0.000007   if a:bufnr is# -2 || a:bufnr is# 0
    3              0.000034     let s:head_cache = {}
    3              0.000019     let s:last_time = reltime()
    3              0.000002     return ''
                              endif
                              let dir = s:Dir(a:bufnr)
                              if len(dir)
                                let s:last_times[s:cpath(dir)] = reltime()
                                if has_key(s:head_cache, dir)
                                  call remove(s:head_cache, dir)
                                endif
                              endif
                              return ''

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:832
Called 156 times
Total time:   0.004778
 Self time:   0.001920

count  total (s)   self (s)
  156   0.004043   0.001184   let id = coc#float#get_related(a:winid, 'scrollbar')
  156              0.000280   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
  156              0.000061   endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:88
Called 3 times
Total time:   0.000127
 Self time:   0.000018

count  total (s)   self (s)
    3   0.000126   0.000017   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/term.vim:26
Called 10 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
   10              0.000032   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
   10              0.000004   endif

FUNCTION  <SNR>213_get()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/state.vim:13
Called 49 times
Total time:   0.000306
 Self time:   0.000306

count  total (s)   self (s)
   49              0.000115     if !exists('t:tagbar_state')
                                    let t:tagbar_state = s:State.New()
   49              0.000018     endif
                            
   49              0.000048     return t:tagbar_state

FUNCTION  airline#util#getwinvar()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:82
Called 109 times
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
  109              0.000274     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>163_sh_autocmd_handler()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:353
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000008   if exists('#airline')
    3              0.000013     unlet! b:airline_head b:airline_do_mq_check
    3              0.000001   endif

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/po.vim:64
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    3              0.000013   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * call s:autocmd_handler()
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    3              0.000001   endif

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 3 times
Total time:   0.000047
 Self time:   0.000023

count  total (s)   self (s)
    3   0.000045   0.000021   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  airline#update_statusline()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline.vim:144
Called 3 times
Total time:   0.060766
 Self time:   0.000231

count  total (s)   self (s)
    3   0.000140   0.000025   if airline#util#stl_disabled(winnr())
                                return
    3              0.000002   endif
    3              0.000035   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    3   0.034645   0.000033   call airline#update_statusline_inactive(range)
                            
    3              0.000008   unlet! w:airline_render_left w:airline_render_right
    3              0.000039   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    3              0.000007   let w:airline_active = 1
    3              0.000016   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    3   0.025862   0.000053   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  airline#extensions#tagbar#currenttag()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:32
Called 272 times
Total time:   0.019971
 Self time:   0.005974

count  total (s)   self (s)
  272              0.000668   if get(w:, 'airline_active', 0)
  272              0.000277     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
  272              0.000118     endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
  272              0.000817     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   28   0.014265   0.000268       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags, get(g:, 'airline#extensions#tagbar#searchmethod', 'nearest-stl'))
   28              0.000058       let s:airline_tagbar_last_lookup_time = localtime()
  272              0.000093     endif
  272              0.000391     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  tagbar#state#get_current_file()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/state.vim:1
Called 46 times
Total time:   0.001071
 Self time:   0.000416

count  total (s)   self (s)
   46   0.001047   0.000392     return s:get().getCurrent(a:force_current)

FUNCTION  <SNR>202_IsValidFile()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:3393
Called 3 times
Total time:   0.000532
 Self time:   0.000510

count  total (s)   self (s)
    3   0.000050   0.000027     call tagbar#debug#log('Checking if file is valid [' . a:fname . ']')
                            
    3              0.000010     if a:fname ==# '' || a:ftype ==# ''
                                    call tagbar#debug#log('Empty filename or type')
                                    return 0
    3              0.000002     endif
                            
    3              0.000051     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') ==# ''
                                    call tagbar#debug#log('File not readable')
                                    return 0
    3              0.000002     endif
                            
    3              0.000144     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call tagbar#debug#log('File is marked as ignored')
                                    return 0
    3              0.000002     endif
                            
    3              0.000126     let winnr = bufwinnr(a:fname)
    3              0.000016     if winnr != -1 && getwinvar(winnr, '&diff')
                                    call tagbar#debug#log('Window is in diff mode')
                                    return 0
    3              0.000002     endif
                            
    3              0.000007     if &previewwindow
                                    call tagbar#debug#log('In preview window')
                                    return 0
    3              0.000002     endif
                            
    3              0.000013     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call tagbar#debug#log('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
    3              0.000002     endif
                            
    3              0.000005     return 1

FUNCTION  <SNR>202_Init()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:209
Called 28 times
Total time:   0.000571
 Self time:   0.000571

count  total (s)   self (s)
   28              0.000046     if s:checked_ctags == 2 && a:silent
                                    return 0
   28              0.000038     elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
   28              0.000011     endif
                            
   28              0.000026     if !s:type_init_done
                                    call s:InitTypes()
   28              0.000009     endif
                            
   28              0.000031     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
   28              0.000009     endif
                            
   28              0.000033     let s:init_done = 1
   28              0.000021     return 1

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 272 times
Total time:   0.019169
 Self time:   0.006878

count  total (s)   self (s)
  272              0.000979   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
  272              0.000087   endif
  272   0.014584   0.002293   return {b:source_func}()

FUNCTION  <SNR>209_handle_double_hunk()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 3 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000021   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    3              0.000001   endif
                            
    3              0.000003   return a:modified_lines

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 9 times
Total time:   0.000308
 Self time:   0.000104

count  total (s)   self (s)
    9   0.000157   0.000040   let summary = gitgutter#hunk#summary(a:bufnr)
    9              0.000012   let summary[1] += a:count
    9   0.000136   0.000048   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>216_getClosedParentTline()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/prototypes/basetag.vim:130
Called 1 time
Total time:   0.000038
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000002     let tagline  = self.tline
                            
                                " Find the first closed parent, starting from the top of the hierarchy.
    1              0.000001     let parents   = []
    1              0.000001     let curparent = self.parent
    2              0.000003     while !empty(curparent)
    1              0.000002         call add(parents, curparent)
    1              0.000002         let curparent = curparent.parent
    2              0.000001     endwhile
    2              0.000003     for parent in reverse(parents)
    1   0.000011   0.000006         if parent.isFolded()
                                        let tagline = parent.tline
                                        break
    1              0.000000         endif
    2              0.000001     endfor
                            
    1              0.000001     return tagline

FUNCTION  <SNR>202_HighlightTag()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:2229
Called 3 times
Total time:   0.029696
 Self time:   0.027685

count  total (s)   self (s)
                            
    3              0.000004     if g:tagbar_no_autocmds
                                    " If no autocmds are enabled, then it doesn't make sense to highlight
                                    " anything as the cursor can move around and any highlighting would be
                                    " inaccurate
                                    return
    3              0.000001     endif
                            
    3              0.000003     let tagline = 0
                            
    3              0.000006     let force = a:0 > 0 ? a:1 : 0
                            
    3              0.000002     if a:0 > 1
                                    let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0, a:2)
    3              0.000002     else
    3   0.001783   0.000019         let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0)
    3              0.000001     endif
    3              0.000004     if !empty(tag)
    3              0.000004         let tagline = tag.tline
    3              0.000001     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
    3              0.000006     if !force && tagline ==# s:last_highlight_tline
    2              0.000001         return
    1              0.000000     else
    1              0.000003         let s:last_highlight_tline = tagline
    1              0.000000     endif
                            
    1   0.000121   0.000115     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    1              0.000001     if tagbarwinnr == -1
                                    return
    1              0.000000     endif
                            
    1              0.000001     if tagbarwinnr == winnr()
                                    let in_tagbar = 1
    1              0.000000     else
    1              0.000001         let in_tagbar = 0
    1              0.000001         let prevwinnr = winnr()
    1   0.000093   0.000007         call s:goto_win('p', 1)
    1              0.000002         let pprevwinnr = winnr()
    1   0.000041   0.000007         call s:goto_win(tagbarwinnr, 1)
    1              0.000000     endif
                            
    1              0.000001     try
    1              0.000003         match none
                            
                                    " No tag above cursor position so don't do anything
    1              0.000001         if tagline == 0
                                        return
    1              0.000000         endif
                            
    1              0.000002         if g:tagbar_autoshowtag == 1 || a:openfolds
                                        call s:OpenParents(tag)
    1              0.000000         endif
                            
                                    " Check whether the tag is inside a closed fold and highlight the parent
                                    " instead in that case
    1   0.000050   0.000012         let tagline = tag.getClosedParentTline()
                            
                                    " Parent tag line number is invalid, better don't do anything
    1              0.000001         if tagline <= 0
                                        return
    1              0.000000         endif
                            
                                    " Go to the line containing the tag
    1              0.000004         execute tagline
                            
                                    " Make sure the tag is visible in the window
    1              0.000004         call winline()
                            
    1              0.000004         let foldpat = '[' . g:tagbar#icon_open . g:tagbar#icon_closed . ' ]'
                            
                                    " If printing the line number of the tag to the left, and the tag is
                                    " visible (I.E. parent isn't folded)
    1              0.000004         let identifier = '\zs\V' . escape(tag.name, '/\') . '\m\ze'
    1              0.000002         if g:tagbar_show_tag_linenumbers == 2 && tagline == tag.tline
                                        let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\[[0-9]\+\] \?' . identifier . '/'
    1              0.000000         else
    1              0.000004             let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\?' . identifier . '/'
    1              0.000000         endif
    1   0.000011   0.000006         call tagbar#debug#log("Highlight pattern: '" . pattern . "'")
    1              0.000003         if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
    1              0.000011             execute 'match TagbarHighlight ' . pattern
                                    else
                                        execute 'match Search ' . pattern
    1              0.000000         endif
    1              0.000001     finally
    1              0.000001         if !in_tagbar
    1   0.000042   0.000006             call s:goto_win(pprevwinnr, 1)
    1   0.000047   0.000005             call s:goto_win(prevwinnr, 1)
    1              0.000000         endif
    1              0.027369         redraw
    1              0.000002     endtry

FUNCTION  xolox#misc#cursorhold#autocmd()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-misc/autoload/xolox/misc/cursorhold.vim:48
Called 3 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
    3              0.000017   for handler in g:xolox#misc#cursorhold#handlers
                                let function = handler['function']
                                let last_run = get(handler, 'last_run', 0)
                                let interval = get(handler, 'interval', 4)
                                call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
                                let time_until_next_run = (last_run + interval) - localtime()
                                if time_until_next_run > 0
                                  call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
                                else
                                  call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
                                  call call(function, get(handler, 'arguments', []))
                                  let handler['last_run'] = localtime()
                                endif
    3              0.000004   endfor

FUNCTION  <SNR>208_is_modified()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 9 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    9              0.000020   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline.vim:173
Called 3 times
Total time:   0.034612
 Self time:   0.000474

count  total (s)   self (s)
    3   0.000094   0.000018   if airline#util#stl_disabled(winnr())
                                return
    3              0.000001   endif
   13              0.000018   for nr in a:range
   10   0.000341   0.000084     if airline#util#stl_disabled(nr)
                                  continue
   10              0.000004     endif
   10              0.000031     call setwinvar(nr, 'airline_active', 0)
   10              0.000053     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   10              0.000017     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
   10              0.000004     endif
   10   0.033936   0.000131     call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
   13              0.000010   endfor

FUNCTION  <SNR>155_invoke_funcrefs()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline.vim:194
Called 13 times
Total time:   0.059614
 Self time:   0.000630

count  total (s)   self (s)
   13   0.000430   0.000082   let builder = airline#builder#new(a:context)
   13   0.009005   0.000163   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   13              0.000017   if err == 1
   10   0.049873   0.000080     let a:context.line = builder.build()
   10              0.000087     let s:contexts[a:context.winnr] = a:context
   10              0.000034     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
   10              0.000121     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
   13              0.000006   endif

FUNCTION  <SNR>163_config_fugitive_branch()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:99
Called 272 times
Total time:   0.150897
 Self time:   0.005558

count  total (s)   self (s)
  272   0.145928   0.002561   let s:vcs_config['git'].branch = exists('*FugitiveHead') ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
  272   0.004083   0.002111   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
  272              0.000119   endif

FUNCTION  gitgutter#all()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 3 times
Total time:   0.023846
 Self time:   0.002696

count  total (s)   self (s)
    3              0.000015   let visible = tabpagebuflist()
                            
  129              0.000231   for bufnr in range(1, bufnr('$') + 1)
  126              0.000185     if buflisted(bufnr)
   69              0.000922       let file = expand('#'.bufnr.':p')
   69              0.000093       if !empty(file)
   66              0.000115         if index(visible, bufnr) != -1
    3   0.020006   0.000053           call gitgutter#process_buffer(bufnr, a:force)
   63              0.000041         elseif a:force
   63   0.001574   0.000378           call s:reset_tick(bufnr)
   66              0.000022         endif
   69              0.000021       endif
  126              0.000037     endif
  129              0.000073   endfor

FUNCTION  coc#float#get_float_win_list()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:657
Called 3 times
Total time:   0.001047
 Self time:   0.001047

count  total (s)   self (s)
    3              0.000006   let res = []
    3              0.000016   let all = get(a:, 1, 0)
    3              0.000006   if s:is_vim
                                if s:popup_list_api
                                  return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(all ? '' : '&& getwinvar(v:val, "float", 0)'))
                                endif
                                return filter(s:popup_list, 's:popup_visible(v:val)')
    3              0.000026   elseif has('nvim') && exists('*nvim_win_get_config')
    3              0.000007     let res = []
   17              0.000042     for i in range(1, winnr('$'))
   14              0.000037       let id = win_getid(i)
   14              0.000114       let config = nvim_win_get_config(id)
   14              0.000595       if empty(config) || empty(config['relative'])
    6              0.000010         continue
    8              0.000005       endif
                                  " ignore border & button window & others
    8              0.000021       if !all && !getwinvar(id, 'float', 0)
                                    continue
    8              0.000004       endif
    8              0.000027       call add(res, id)
   11              0.000012     endfor
    3              0.000006     return res
                              endif
                              return []

FUNCTION  FugitiveHead()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:232
Called 272 times
Total time:   0.143367
 Self time:   0.009188

count  total (s)   self (s)
  272              0.001462   if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
  272              0.000274   elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
  272              0.000136   else
  272   0.012865   0.001512     let dir = FugitiveGitDir()
  272              0.001027     let arg = get(a:, 1, 0)
  272              0.000249   endif
  272              0.000796   if empty(dir)
                                return ''
  272              0.000094   endif
  272   0.124481   0.001655   return fugitive#Head(arg, dir)

FUNCTION  coc#window#tabnr()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/window.vim:1
Called 3 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000012   if exists('*win_execute')
    3              0.000009     let ref = {}
    3              0.000023     call win_execute(a:winid, 'let ref["out"] = tabpagenr()')
    3              0.000010     return get(ref, 'out', -1)
                              elseif has('nvim')
                                let info = getwininfo(a:winid)
                                return empty(info) ? -1 : info[0]['tabnr']
                              else
                                throw 'win_execute() not exists, please upgrade your vim.'
                              endif

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:255
Called 7 times
Total time:   0.071322
 Self time:   0.009924

count  total (s)   self (s)
    7              0.000013     let bufnr = a:0 ? a:1 : ''
    7              0.000019     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
    7              0.000039     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    7              0.000014     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    7              0.000010     let airline_grouplist = []
    7              0.000053     let buffers_in_tabpage = sort(tabpagebuflist())
    7              0.000013     if exists("*uniq")
    7              0.000034       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    7              0.000003     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
   14              0.000022     for mode in reverse(mapped)
    7              0.000027       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    5              0.000012         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  105              0.000171         for kvp in items(dict)
  100              0.000139           let mode_colors = kvp[1]
  100              0.000115           let name = kvp[0]
  100              0.000209           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                        let name = 'airline_c'.bufnr
  100              0.000037           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
  100              0.000439           if name =~# 'airline_c\d\+'
   15              0.000085             let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   15              0.000040             if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
    7              0.000004               continue
    8              0.000003             endif
   85              0.000329           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
   40              0.000026             continue
   53              0.000018           endif
   53   0.000636   0.000328           if s:group_not_done(airline_grouplist, name.suffix)
   53   0.011437   0.000365             call airline#highlighter#exec(name.suffix, mode_colors)
   53              0.000022           endif
                            
   53              0.000098           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
   53              0.000022           endif
                            
  159              0.000258           for accent in keys(s:accents)
  106              0.000211             if !has_key(p.accents, accent)
                                          continue
  106              0.000037             endif
  106              0.000275             let colors = copy(mode_colors)
  106              0.000255             if p.accents[accent][0] != ''
   53              0.000108               let colors[0] = p.accents[accent][0]
  106              0.000038             endif
  106              0.000140             if p.accents[accent][2] != ''
   53              0.000081               let colors[2] = p.accents[accent][2]
  106              0.000035             endif
  106              0.000140             if len(colors) >= 5
  106              0.000273               let colors[4] = get(p.accents[accent], 4, '')
                                        else
                                          call add(colors, get(p.accents[accent], 4, ''))
  106              0.000036             endif
  106   0.001369   0.000777             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  106   0.022621   0.000777               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  106              0.000047             endif
  159              0.000084           endfor
   58              0.000026         endfor
                            
    5              0.000008         if empty(s:separators)
                                      " nothing to be done
                                      continue
    5              0.000002         endif
                                    " TODO: optimize this
   60              0.000100         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
   55   0.028147   0.000566           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   60              0.000036         endfor
    7              0.000003       endif
   14              0.000017     endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim:32
Called 177 times
Total time:   0.001190
 Self time:   0.001190

count  total (s)   self (s)
  177              0.000674   if empty(s:client) || s:client['running'] == 0
                                return 0
  177              0.000071   endif
  177              0.000135   return 1

FUNCTION  tagbar#state#set_current_file()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/state.vim:5
Called 3 times
Total time:   0.000043
 Self time:   0.000022

count  total (s)   self (s)
    3   0.000042   0.000021     call s:get().setCurrentFile(a:fileinfo)

FUNCTION  <SNR>204_Tree()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:502
Called 272 times
Total time:   0.017517
 Self time:   0.001637

count  total (s)   self (s)
  272   0.017388   0.001508   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  fugitive#CommonDir()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:469
Called 272 times
Total time:   0.005564
 Self time:   0.005564

count  total (s)   self (s)
  272              0.000399   if empty(a:dir)
                                return ''
  272              0.000111   endif
  272              0.000605   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
  272              0.000110   endif
  272              0.000537   return s:commondirs[a:dir]

FUNCTION  airline#parts#ffenc()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 272 times
Total time:   0.012264
 Self time:   0.012264

count  total (s)   self (s)
  272              0.000898   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  272              0.000555   let bomb     = &bomb ? '[BOM]' : ''
  272              0.002245   let noeolf   = &eol ? '' : '[!EOL]'
  272              0.002671   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  272              0.003952   if expected is# &fenc.bomb.noeolf.ff
                                return ''
  272              0.000122   else
  272              0.001292     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 15 times
Total time:   0.000252
 Self time:   0.000234

count  total (s)   self (s)
   15              0.000174   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   12              0.000016     return a:arg
    3   0.000033   0.000015   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    3              0.000001   else
    3              0.000007     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:136
Called 272 times
Total time:   0.005418
 Self time:   0.005418

count  total (s)   self (s)
  272              0.001766   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  272              0.003406   return match(a:name, pat) > -1

FUNCTION  <SNR>61_not_git_dir()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 6 times
Total time:   0.000699
 Self time:   0.000101

count  total (s)   self (s)
    6   0.000695   0.000098   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  VMInfos()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-visual-multi/plugin/visual-multi.vim:97
Called 272 times
Total time:   0.001750
 Self time:   0.001750

count  total (s)   self (s)
  272              0.000983     if !exists('b:VM_Selection') || empty(b:VM_Selection)
  272              0.000476         return {}
                                endif
                            
                                let infos = {}
                                let VM = b:VM_Selection
                            
                                let m = g:Vm.mappings_enabled ?    'M' : 'm'
                                let s = VM.Vars.single_region ?    'S' : 's'
                                let l = VM.Vars.multiline ?        'V' : 'v'
                            
                                let infos.current = VM.Vars.index + 1
                                let infos.total = len(VM.Regions)
                                let infos.ratio = infos.current . ' / ' . infos.total
                                let infos.patterns = VM.Vars.search
                                let infos.status = m.s.l
                                return infos

FUNCTION  <SNR>204_Slash()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:146
Called 272 times
Total time:   0.000412
 Self time:   0.000412

count  total (s)   self (s)
  272              0.000324     return a:path

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:216
Called 27 times
Total time:   0.000513
 Self time:   0.000513

count  total (s)   self (s)
   27              0.000199   let matches = matchlist(a:line, s:hunk_re)
   27              0.000046   if len(matches) > 0
   27              0.000045     let from_line  = str2nr(matches[1])
   27              0.000059     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   27              0.000038     let to_line    = str2nr(matches[3])
   27              0.000054     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   27              0.000047     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>160_group_not_done()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 159 times
Total time:   0.000900
 Self time:   0.000900

count  total (s)   self (s)
  159              0.000378     if index(a:list, a:name) == -1
  159              0.000320       call add(a:list, a:name)
  159              0.000126       return 1
                                else
                                  if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
                                  endif
                                  return 0
                                endif

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 71 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
   71              0.000102   let x = a:i - 1
   81              0.000074   while x >= 0
   68              0.000112     let group = a:sections[x][0]
   68              0.000118     if group != '' && group != '|'
   58              0.000051       return group
   10              0.000004     endif
   10              0.000008     let x = x - 1
   23              0.000014   endwhile
   13              0.000009   return ''

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:199
Called 276 times
Total time:   0.002195
 Self time:   0.002195

count  total (s)   self (s)
  276              0.001261   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
  276              0.000121   endif

FUNCTION  <SNR>207_reset_summary()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 3 times
Total time:   0.000053
 Self time:   0.000019

count  total (s)   self (s)
    3   0.000052   0.000018   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#parts#paste()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 272 times
Total time:   0.000906
 Self time:   0.000906

count  total (s)   self (s)
  272              0.000807   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>153_is_excluded_window()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 10 times
Total time:   0.001542
 Self time:   0.001542

count  total (s)   self (s)
   10              0.000027   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
   10              0.000007   endfor
                            
   40              0.000042   for matchw in g:airline_exclude_filenames
   30              0.001299     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
   30              0.000011     endif
   40              0.000018   endfor
                            
   10              0.000015   if g:airline_exclude_preview && &previewwindow
                                return 1
   10              0.000003   endif
                            
   10              0.000008   return 0

FUNCTION  <SNR>163_update_untracked()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:199
Called 272 times
Total time:   0.024466
 Self time:   0.021289

count  total (s)   self (s)
  272              0.004422   let file = expand("%:p")
  272              0.001760   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
  272              0.000113   endif
                            
  272              0.000342   let needs_update = 1
  272              0.001010   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  816              0.001361   for vcs in keys(s:vcs_config)
  544              0.002153     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  544              0.000213     endif
  544              0.001348     if has_key(s:vcs_config[vcs].untracked, file)
  272              0.000277       let needs_update = 0
  272   0.005696   0.002519       call airline#extensions#branch#update_untracked_config(file, vcs)
  544              0.000308     endif
  816              0.000456   endfor
                            
  272              0.000255   if !needs_update
  272              0.000185     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  <SNR>200_on_exit_nvim()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 3 times
Total time:   0.005957
 Self time:   0.000069

count  total (s)   self (s)
    3              0.000006   if !a:exit_code
    3   0.005947   0.000059     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    3              0.000001   endif

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:190
Called 272 times
Total time:   0.003177
 Self time:   0.003177

count  total (s)   self (s)
  272              0.000830   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
  272              0.001010   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
  272              0.000101   endif

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline.vim:163
Called 3 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    3              0.000015   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    3              0.000003   endif

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 3 times
Total time:   0.019039
 Self time:   0.000624

count  total (s)   self (s)
    3   0.000068   0.000017   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
    3              0.000001   endif
                            
    3   0.000056   0.000016   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    3              0.000001   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    3              0.000003   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    3              0.000008   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    3              0.000006   let s:counter = (s:counter + 1) % 20
    3              0.000007   let buff_file .= '.'.s:counter
                            
    3   0.000143   0.000016   let extension = gitgutter#utility#extension(a:bufnr)
    3              0.000004   if !empty(extension)
    3              0.000006     let buff_file .= '.'.extension
    3              0.000001   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    3   0.000677   0.000091   call s:write_buffer(a:bufnr, buff_file)
                            
    3              0.000005   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    3              0.000010     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    3              0.000006     let from_file .= '.'.s:counter
                            
    3              0.000005     if !empty(extension)
    3              0.000005       let from_file .= '.'.extension
    3              0.000001     endif
                            
                                " Write file from index to temporary file.
    3   0.000302   0.000095     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000017     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000001   endif
                            
                              " Call git-diff.
    3              0.000009   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    3              0.000003   if s:c_flag
    3              0.000004     let cmd .= ' -c "diff.autorefreshindex=0"'
    3              0.000004     let cmd .= ' -c "diff.noprefix=false"'
    3              0.000003     let cmd .= ' -c "core.safecrlf=false"'
    3              0.000001   endif
    3              0.000012   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    3              0.000007   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    3   0.000087   0.000021     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    3              0.000001   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    3              0.000004   let cmd .= ' || exit 0'
                            
    3              0.000003   let cmd .= ')'
                            
    3   0.000430   0.000021   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    3   0.000024   0.000018   if g:gitgutter_async && gitgutter#async#available()
    3   0.017018   0.000096     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    3              0.000010     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:173
Called 3 times
Total time:   0.005889
 Self time:   0.000262

count  total (s)   self (s)
    3   0.000102   0.000020   call gitgutter#debug#log(a:diff)
                            
    3              0.000006   if !bufexists(a:bufnr)
                                return
    3              0.000001   endif
                            
    3   0.001264   0.000039   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    3   0.003352   0.000035   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    3              0.000005   let signs_count = len(modified_lines)
    3              0.000006   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    3              0.000001   else
    3              0.000006     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    3   0.000983   0.000042       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    3              0.000002     endif
    3              0.000001   endif
                            
    3   0.000098   0.000035   call s:save_last_seen_change(a:bufnr)
    3              0.000020   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    3              0.000001   endif

FUNCTION  airline#parts#readonly()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 272 times
Total time:   0.010059
 Self time:   0.004641

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  272   0.007919   0.002501   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
  272              0.000120   endif
  272              0.000556   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
  272              0.000111   else
  272              0.000428     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:931
Called 272 times
Total time:   0.122826
 Self time:   0.015570

count  total (s)   self (s)
  272              0.000813   let dir = a:0 > 1 ? a:2 : s:Dir()
  272              0.000364   if empty(dir)
                                return ''
  272              0.000153   endif
  272   0.109093   0.001837   let file = fugitive#Find('.git/HEAD', dir)
  272              0.003798   let ftime = getftime(file)
  272              0.000310   if ftime == -1
                                return ''
  272              0.001168   elseif ftime != get(s:head_cache, file, [-1])[0]
    4              0.000112     let s:head_cache[file] = [ftime, readfile(file)[0]]
  272              0.000106   endif
  272              0.000569   let head = s:head_cache[file][1]
  272              0.000429   let len = a:0 ? a:1 : 0
  272              0.001112   if head =~# '^ref: '
  272              0.000256     if len < 0
                                  return strpart(head, 5)
  272              0.000119     else
  272              0.002632       return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                                endif
                              elseif head =~# '^\x\{40,\}$'
                                return len < 0 ? head : strpart(head, 0, len)
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#tagbar#get_status()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:16
Called 3 times
Total time:   0.006197
 Self time:   0.000077

count  total (s)   self (s)
    3   0.000094   0.000020   let builder = airline#builder#new({ 'active': a:1 })
    3   0.000030   0.000018   call builder.add_section('airline_a', s:spc.'Tagbar'.s:spc)
    3   0.000019   0.000012   call builder.add_section('airline_b', s:spc.a:2.s:spc)
    3   0.000017   0.000010   call builder.add_section('airline_c', s:spc.a:3.s:spc)
    3   0.006033   0.000013   return builder.build()

FUNCTION  nvim_treesitter#foldexpr()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/nvim-treesitter/autoload/nvim_treesitter.vim:5
Called 40 times
Total time:   0.000977
 Self time:   0.000977

count  total (s)   self (s)
   40              0.000943 	return luaeval(printf('require"nvim-treesitter.fold".get_fold_indic(%d)', v:lnum))

FUNCTION  <SNR>177_setup_path()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 6 times
Total time:   0.000312
 Self time:   0.000056

count  total (s)   self (s)
    6   0.000308   0.000052   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  airline#util#doautocmd()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:176
Called 10 times
Total time:   0.001041
 Self time:   0.000230

count  total (s)   self (s)
   10              0.000037   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
   10              0.000004   endif
   10   0.000977   0.000166   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 38 times
Total time:   0.012167
 Self time:   0.002735

count  total (s)   self (s)
   38              0.000061   if a:group1 == a:group2
                                return 0
   38              0.000014   endif
   38   0.007253   0.002128   let color1 = airline#highlighter#get_highlight(a:group1)
   38   0.004623   0.000317   let color2 = airline#highlighter#get_highlight(a:group2)
   38              0.000150   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  <SNR>202_AutoUpdate()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:2819
Called 3 times
Total time:   0.039844
 Self time:   0.001423

count  total (s)   self (s)
    3   0.000075   0.000039     call tagbar#debug#log('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
    3              0.000012     let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    3              0.000009     if exists('s:tagbar_qf_active')
                                    return
    3              0.000008     elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call tagbar#debug#log('Still opening window, stopping processing')
                                    return
    3              0.000002     endif
                            
                                " Get the filetype of the file we're about to process
    3              0.000189     let bufnr = bufnr(a:fname)
    3              0.000019     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    3              0.000006     if ftype ==# 'tagbar'
                                    call tagbar#debug#log('In Tagbar window, stopping processing')
                                    return
    3              0.000002     endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    3              0.000030     let sftype = get(split(ftype, '\.'), 0, '')
    3   0.000088   0.000059     call tagbar#debug#log("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    3   0.000582   0.000050     if !s:IsValidFile(a:fname, sftype)
                                    call tagbar#debug#log('Not a valid file, stopping processing')
                                    let s:nearby_disabled = 1
                                    return
    3              0.000002     endif
                            
    3              0.000006     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
    3   0.000049   0.000033     if s:known_files.has(a:fname)
    3   0.000037   0.000020         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
    3              0.000070         if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call tagbar#debug#log('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
    3              0.000003         else
    3   0.000054   0.000029             call tagbar#debug#log('File data seems up to date [' . a:fname . ']')
    3              0.000002         endif
                                elseif !s:known_files.has(a:fname)
                                    call tagbar#debug#log('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
    3              0.000002     endif
                            
    3              0.000085     if no_display
                                    return
    3              0.000001     endif
                            
    3   0.000026   0.000016     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
    3              0.000004     if empty(fileinfo)
                                    call tagbar#debug#log('fileinfo empty after processing [' . a:fname . ']')
                                    return
    3              0.000001     endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
    3   0.000537   0.000400     if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(tagbar#state#get_current_file(0)) && a:fname != tagbar#state#get_current_file(0).fpath))
                                    call s:RenderContent(fileinfo)
    3              0.000001     endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
    3              0.000004     if !empty(fileinfo)
    3   0.000040   0.000017         call tagbar#debug#log('Setting current file [' . a:fname . ']')
    3   0.000064   0.000021         call tagbar#state#set_current_file(fileinfo)
    3              0.000007         let s:nearby_disabled = 0
    3              0.000001     endif
                            
    3   0.029717   0.000021     call s:HighlightTag(0)
    3   0.007876   0.000045     call s:SetStatusLine()
    3   0.000056   0.000031     call tagbar#debug#log('AutoUpdate finished successfully')

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 102 times
Total time:   0.001230
 Self time:   0.001230

count  total (s)   self (s)
  102              0.000127   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
  102              0.000241   let ggvars = getbufvar(buffer, 'gitgutter')
  102              0.000157   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
  102              0.000053   endif
  102              0.000265   let ggvars[a:varname] = a:val

FUNCTION  <SNR>163_format_name()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:77
Called 4 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    4              0.000004     return a:name

FUNCTION  <SNR>78_notify()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim:189
Called 177 times
Total time:   0.014883
 Self time:   0.013960

count  total (s)   self (s)
  177   0.002052   0.001129   let channel = coc#client#get_channel(self)
  177              0.000241   if empty(channel)
                                return ''
  177              0.000062   endif
  177              0.000134   try
  177              0.000141     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  177              0.000098     else
  177              0.007355       call call('rpcnotify', [channel, a:method] + a:args)
  177              0.000133     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  177              0.000180   endtry

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:53
Called 3 times
Total time:   0.000058
 Self time:   0.000032

count  total (s)   self (s)
    3   0.000047   0.000021   call <sid>check_defined_section(a:name)
    3              0.000008   let w:airline_section_{a:name} .= a:value

FUNCTION  <SNR>202_goto_win()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:3652
Called 16 times
Total time:   0.000981
 Self time:   0.000872

count  total (s)   self (s)
                                "Do not go to a popup window to avoid errors.
                                "Hence, check first if a:winnr is an integer,
                                "if this integer is equal to 0,
                                "the window is a popup window
   16              0.000061     if has('popupwin')
                                    if type(a:winnr) == type(0) && a:winnr == 0
                                        return
                                    endif
                                    if a:winnr ==# 'p' && winnr('#') == 0
                                        return
                                    endif
   16              0.000006     endif
   16              0.000079     let cmd = type(a:winnr) == type(0) ? a:winnr . 'wincmd w' : 'wincmd ' . a:winnr
   16              0.000037     let noauto = a:0 > 0 ? a:1 : 0
                            
   16   0.000231   0.000122     call tagbar#debug#log('goto_win(): ' . cmd . ', ' . noauto)
                            
   16              0.000014     if noauto
   16              0.000378         noautocmd execute cmd
                                else
                                    execute cmd
   16              0.000007     endif

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/plugin/gitgutter.vim:189
Called 268 times
Total time:   0.007064
 Self time:   0.001878

count  total (s)   self (s)
  268   0.006946   0.001759   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  coc#float#close_related()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:840
Called 3 times
Total time:   0.000232
 Self time:   0.000172

count  total (s)   self (s)
    3   0.000090   0.000030   let tabnr = coc#window#tabnr(a:winid)
    3              0.000004   if tabnr != -1
    3              0.000010     let timer = gettabwinvar(tabnr, a:winid, 'timer', 0)
    3              0.000002     if timer
                                  call timer_stop(timer)
    3              0.000003     endif
    3              0.000007     let kind = get(a:, 1, '')
    3              0.000009     let winids = gettabwinvar(tabnr, a:winid, 'related', [])
    3              0.000008     for id in winids
                                  if s:is_vim
                                    " vim doesn't throw
                                    noa call popup_close(id)
                                  else
                                    if empty(kind) || gettabwinvar(tabnr, id, 'kind', '') ==# kind
                                      if nvim_win_is_valid(id)
                                        noa call nvim_win_close(id, 1)
                                      endif
                                    endif
                                  endif
    3              0.000004     endfor
    3              0.000002   endif

FUNCTION  <SNR>175_get_transitioned_seperator()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 48 times
Total time:   0.030986
 Self time:   0.001557

count  total (s)   self (s)
   48              0.000048   let line = ''
   48              0.000190   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   48              0.000022   else
   48   0.029768   0.000339     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   48              0.000166     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   48              0.000160     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   48              0.000244     let line .= '%#'.a:group.'#'
   48              0.000023   endif
   48              0.000051   return line

FUNCTION  airline#highlighter#exec()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 269 times
Total time:   0.058103
 Self time:   0.020869

count  total (s)   self (s)
  269              0.000306     if pumvisible()
                                  return
  269              0.000089     endif
  269              0.000305     let colors = a:colors
  269              0.000525     if len(colors) == 4
  103              0.000184       call add(colors, '')
  269              0.000090     endif
                                " colors should always be string values
  269              0.004478     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
  269              0.000283     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  269              0.000095     endif
  269   0.031970   0.001780     let old_hi = airline#highlighter#get_highlight(a:group)
  269              0.002856     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  269   0.006021   0.001419     let colors = s:CheckDefined(colors)
  269   0.004095   0.001653     if old_hi != new_hi || !s:hl_group_exists(a:group)
                                  let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
                                  try
                                    exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
                                  endtry
                                  if has_key(s:hl_groups, a:group)
                                    let s:hl_groups[a:group] = colors
                                  endif
  269              0.000086     endif

FUNCTION  <SNR>200_on_stderr_nvim()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000006   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    3              0.000001   endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 15 times
Total time:   0.000336
 Self time:   0.000157

count  total (s)   self (s)
   15   0.000256   0.000104   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   15   0.000073   0.000046   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>75_AsyncRequest()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/plugin/coc.vim:112
Called 3 times
Total time:   0.000576
 Self time:   0.000149

count  total (s)   self (s)
    3              0.000041   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    3              0.000015   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    3              0.000002   endif
    3   0.000463   0.000035   call coc#rpc#notify(a:name, a:args)
    3              0.000003   return ''

FUNCTION  <SNR>208_is_removed()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 21 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
   21              0.000031   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>160_CheckDefined()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 269 times
Total time:   0.004602
 Self time:   0.004602

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
  269              0.000645     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  269              0.000098     endif
  269              0.000664     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                  return a:colors
  269              0.000083     endif
                            
  269              0.000502     for val in a:colors
  269              0.000595       if !empty(val) && val !=# 'NONE'
  269              0.000272         return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>47_on_cursor_moved()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/plugin/airline.vim:83
Called 156 times
Total time:   0.004283
 Self time:   0.003368

count  total (s)   self (s)
  156              0.001669   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
  156              0.000105   endif
  156   0.001952   0.001038   call airline#update_tabline()

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 3 times
Total time:   0.000084
 Self time:   0.000026

count  total (s)   self (s)
    3   0.000082   0.000024   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  <SNR>161_get_hunks_gitgutter()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 272 times
Total time:   0.012291
 Self time:   0.003615

count  total (s)   self (s)
  272   0.003492   0.001880   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    4              0.000003     return ''
  268              0.000101   endif
  268   0.008324   0.001260   return GitGutterGetHunkSummary()

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000021   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 272 times
Total time:   0.006405
 Self time:   0.006405

count  total (s)   self (s)
  272              0.002906   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  272              0.000463   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                elseif !empty(g:airline_symbols.spell)
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
  272              0.000116   endif
  272              0.000199   return ''

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 272 times
Total time:   0.032980
 Self time:   0.026957

count  total (s)   self (s)
  272              0.000980   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  272              0.001590   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
  272              0.000113   endif
  272              0.002320   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  272              0.000630   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
  272              0.000097   endif
  272   0.007780   0.001756   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>175_get_accented_line()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 61 times
Total time:   0.002648
 Self time:   0.002648

count  total (s)   self (s)
   61              0.000079   if a:self._context.active
                                " active window
   24              0.000031     let contents = []
   24              0.000562     let content_parts = split(a:contents, '__accent')
   72              0.000082     for cpart in content_parts
   48              0.000263       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   48              0.000095       call add(contents, cpart)
   72              0.000041     endfor
   24              0.000091     let line = join(contents, a:group)
   24              0.000147     let line = substitute(line, '__restore__', a:group, 'g')
   37              0.000017   else
                                " inactive window
   37              0.000342     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   37              0.000166     let line = substitute(line, '%#__restore__#', '', 'g')
   61              0.000027   endif
   61              0.000058   return line

FUNCTION  <SNR>163_update_hg_branch()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:145
Called 272 times
Total time:   0.014511
 Self time:   0.012947

count  total (s)   self (s)
  272   0.003322   0.001757   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
  272              0.000107   else
  272              0.000581     let s:vcs_config['mercurial'].branch = ''
  272              0.000117   endif

FUNCTION  <SNR>160_get_array()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 551 times
Total time:   0.002607
 Self time:   0.002607

count  total (s)   self (s)
  551              0.002456     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  <SNR>208_process_added()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:293
Called 6 times
Total time:   0.000278
 Self time:   0.000278

count  total (s)   self (s)
    6              0.000007   let offset = 0
   54              0.000049   while offset < a:to_count
   48              0.000054     let line_number = a:to_line + offset
   48              0.000080     call add(a:modifications, [line_number, 'added'])
   48              0.000037     let offset += 1
   54              0.000021   endwhile

FUNCTION  <SNR>208_write_buffer()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:375
Called 3 times
Total time:   0.000587
 Self time:   0.000587

count  total (s)   self (s)
    3              0.000226   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    3              0.000008   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    3              0.000001   endif
                            
    3              0.000009   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    3              0.000001   endif
                            
    3              0.000005   if getbufvar(a:bufnr, '&endofline')
    3              0.000007     call add(bufcontents, '')
    3              0.000001   endif
                            
    3              0.000006   let fenc = getbufvar(a:bufnr, '&fileencoding')
    3              0.000003   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    3              0.000001   endif
                            
    3              0.000005   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='ï»¿'.bufcontents[0]
    3              0.000001   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    3              0.000002   try
    3              0.000252     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    3              0.000003   endtry

FUNCTION  <SNR>163_display_git_branch()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:122
Called 4 times
Total time:   0.000231
 Self time:   0.000156

count  total (s)   self (s)
                              " disable FocusGained autocommand, might cause loops because system() causes
                              " a refresh, which causes a system() command again #2029
    4   0.000047   0.000023   call airline#util#ignore_next_focusgain()
    4              0.000007   let name = b:buffer_vcs_config['git'].branch
    4              0.000003   try
    4   0.000095   0.000044     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
    4              0.000008     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
    4              0.000005     elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
    4              0.000001     endif
                              catch
    4              0.000003   endtry
    4              0.000004   return name

FUNCTION  <SNR>208_is_added()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:273
Called 27 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
   27              0.000041   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>163_update_git_branch()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 272 times
Total time:   0.161068
 Self time:   0.006233

count  total (s)   self (s)
  272   0.003754   0.001583   call airline#util#ignore_next_focusgain()
  272   0.003046   0.001280   if airline#util#has_fugitive()
  272   0.152480   0.001583     call s:config_fugitive_branch()
                              elseif airline#util#has_gina()
                                call s:config_gina_branch()
                              else
                                let s:vcs_config['git'].branch = ''
                                return
  272              0.000120   endif

FUNCTION  airline#parts#crypt()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 272 times
Total time:   0.002812
 Self time:   0.002812

count  total (s)   self (s)
  272              0.002642   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:246
Called 272 times
Total time:   0.219266
 Self time:   0.006960

count  total (s)   self (s)
  272              0.000674   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
  272              0.000115   endif
                            
  272   0.189344   0.001741   call s:update_branch()
  272   0.026332   0.001867   call s:update_untracked()
                            
  272              0.000809   if exists('b:airline_head') && !empty(b:airline_head)
  268              0.000277     return b:airline_head
    4              0.000002   endif
                            
    4              0.000005   let b:airline_head = ''
    4              0.000013   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    4              0.000004   let heads = []
   12              0.000011   for vcs in vcs_priority
    8              0.000015     if !empty(b:buffer_vcs_config[vcs].branch)
    4              0.000008       let heads += [vcs]
    8              0.000003     endif
   12              0.000005   endfor
                            
    8              0.000008   for vcs in heads
    4              0.000005     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
    4              0.000002     endif
    4              0.000006     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
    4              0.000001     endif
    4   0.000295   0.000057     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    4              0.000008     let additional = b:buffer_vcs_config[vcs].untracked
    4              0.000025     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
    4              0.000010       let additional = g:airline_symbols['dirty']
    4              0.000002     endif
    4              0.000006     let b:airline_head .= additional
    8              0.000005   endfor
                            
    4              0.000005   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
    4              0.000002   endif
                            
    4              0.000004   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
    4              0.000001   endif
                            
    4              0.000009   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  'â€¦' : '.')
                                endif
    4              0.000001   endif
                            
    4              0.000005   return b:airline_head

FUNCTION  <SNR>44_CursorHoldUpdate()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-devicons/plugin/webdevicons.vim:401
Called 3 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    3              0.000014   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    3              0.000002   endif
                            
    3              0.000016   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    3              0.000003     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  airline#parts#mode()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 272 times
Total time:   0.009212
 Self time:   0.002397

count  total (s)   self (s)
  272   0.009062   0.002248   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>136_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:40
Called 156 times
Total time:   0.012492
 Self time:   0.011301

count  total (s)   self (s)
                              " Remove any previous match.
  156   0.002049   0.000858   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  156              0.000557   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  156              0.000058   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  156              0.000314   let c_lnum = line('.')
  156              0.000254   let c_col = col('.')
  156              0.000144   let before = 0
                            
  156              0.000365   let text = getline(c_lnum)
  156              0.002268   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  156              0.000240   if empty(matches)
                                let [c_before, c] = ['', '']
  156              0.000081   else
  156              0.000588     let [c_before, c] = matches[1:2]
  156              0.000082   endif
  156              0.002017   let plist = split(&matchpairs, '.\zs[:,]')
  156              0.000414   let i = index(plist, c)
  156              0.000146   if i < 0
                                " not found, in Insert mode try character before the cursor
  156              0.000567     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
  156              0.000072     endif
  156              0.000126     if i < 0
                                  " not found, nothing to do
  156              0.000134       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>136_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:197
Called 156 times
Total time:   0.001192
 Self time:   0.001192

count  total (s)   self (s)
  156              0.000489   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
  156              0.000140   endif

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000009   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    3              0.000002   endif

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 12 times
Total time:   0.000400
 Self time:   0.000137

count  total (s)   self (s)
   12   0.000201   0.000053   let summary = gitgutter#hunk#summary(a:bufnr)
   12              0.000015   let summary[2] += a:count
   12   0.000178   0.000063   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  airline#mode_changed()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline.vim:296
Called 7 times
Total time:   0.000171
 Self time:   0.000137

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    7              0.000087   let g:airline#visual_active = (mode() =~? '[vs]')
    7   0.000072   0.000037   call airline#update_tabline()

FUNCTION  gitgutter#async#execute()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 3 times
Total time:   0.016922
 Self time:   0.016825

count  total (s)   self (s)
    3   0.000103   0.000018   call gitgutter#debug#log('[async] '.a:cmd)
                            
    3              0.000013   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    3   0.000030   0.000017   let command = s:build_command(a:cmd)
                            
    3              0.000006   if has('nvim')
    3              0.016683     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    3              0.000003   endif

FUNCTION  fugitive#Find()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:1713
Called 272 times
Total time:   0.107256
 Self time:   0.055050

count  total (s)   self (s)
  272              0.000687   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
  272              0.001246   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
  272              0.000109   endif
  272   0.001893   0.001482   let rev = s:Slash(a:object)
  272              0.003662   if rev =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
  272              0.001177   elseif rev =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
  272              0.000112   endif
  272   0.015294   0.001710   let dir = call('s:GitDir', a:000)
  272              0.000341   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs\%(\.\.\=$\|\.\.\=/.*\|/.*\|\w:/.*\)')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return ''
                                endif
  272              0.000095   endif
  272   0.018947   0.001430   let tree = s:Tree(dir)
  272   0.014656   0.001647   let urlprefix = s:DirUrlPrefix(dir)
  272              0.000673   let base = len(tree) ? tree : urlprefix . '0'
  272              0.000287   if rev ==# '.git'
                                let f = len(tree) && len(getftype(tree . '/.git')) ? tree . '/.git' : dir
  272              0.000945   elseif rev =~# '^\.git/'
  272              0.000563     let f = strpart(rev, 5)
  272              0.000426     let fdir = dir . '/'
  272   0.007010   0.001446     let cdir = fugitive#CommonDir(dir) . '/'
  272              0.000996     if f =~# '^\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[2:-1] : fdir . f)
  272              0.000668     elseif f =~# '^\.\.\%(/\|$\)'
                                  let f = base . f[2:-1]
  272              0.001770     elseif cdir !=# fdir && ( f =~# '^\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(fdir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
  272              0.000134     else
  272              0.000886       let f = simplify(fdir . f)
  272              0.000115     endif
                              elseif rev ==# ':/'
                                let f = tree
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = urlprefix . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = urlprefix . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                let fdir = dir . '/'
                                let f = fdir . 'index'
                                if len($GIT_INDEX_FILE)
                                  let index_dir = substitute($GIT_INDEX_FILE, '[^/]\+$', '', '')
                                  if s:cpath(index_dir, fdir)
                                    let f = FugitiveVimPath($GIT_INDEX_FILE)
                                  elseif s:cpath(resolve(FugitiveVimPath(index_dir)), fdir)
                                    let f = resolve(FugitiveVimPath($GIT_INDEX_FILE))
                                  endif
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = urlprefix . '0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) ? "@" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$\|^$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                    if empty(commit) && len(file)
                                      let commit = repeat('0', 40)
                                    endif
                                  endif
                                  if len(commit)
                                    let f = urlprefix . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
  272              0.000118   endif
  272   0.003438   0.001317   return FugitiveVimPath(f)

FUNCTION  <SNR>176_build_sections()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 13 times
Total time:   0.003477
 Self time:   0.000615

count  total (s)   self (s)
   72              0.000071   for key in a:keys
   59              0.000122     if (key == 'warning' || key == 'error') && !a:context.active
   14              0.000007       continue
   45              0.000015     endif
   45   0.003124   0.000261     call s:add_section(a:builder, a:context, key)
   58              0.000031   endfor

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 3 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    3              0.000018   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    3              0.000016   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    3              0.000004   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
                                let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    3              0.000001   endif
                            
    3              0.000007   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    3              0.000001   endif

FUNCTION  bufferline#render()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/barbar.nvim/plugin/bufferline.vim:154
Called 6 times
Total time:   0.009034
 Self time:   0.009034

count  total (s)   self (s)
    6              0.008988    let result = luaeval("require'bufferline.render'.render_safe(_A)", a:update_names)
                            
    6              0.000019    if result[0]
    6              0.000015       return result[1]
                               end
                            
                               let error = result[1]
                            
                               BarbarDisable
                               echohl ErrorMsg
                               echom "Barbar detected an error while running. Barbar disabled itself :/"
                               echom "Include this in your report: " . string(error)
                               echohl None

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 9 times
Total time:   0.000328
 Self time:   0.000113

count  total (s)   self (s)
    9   0.000165   0.000042   let summary = gitgutter#hunk#summary(a:bufnr)
    9              0.000014   let summary[0] += a:count
    9   0.000143   0.000050   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>204_can_diffoff()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:6271
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000020   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  airline#extensions#mundo#statusline()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-mundo/autoload/airline/extensions/mundo.vim:13
Called 3 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000004     let builder = a:1
    3              0.000004     if &filetype == 'Mundo'
                                    call builder.add_section('airline_a', get(g:, 'mundo_tree_statusline', 'Mundo'))
                                    call builder.split()
                                    call builder.add_section('airline_z', '%p%%')
                                    return 1
    3              0.000001     endif
    3              0.000002     if &filetype == 'MundoDiff'
                                    call builder.add_section('airline_a', get(g:, 'mundo_preview_statusline', 'Mundo Diff'))
                                    call builder.split()
                                    return 1
    3              0.000001     endif

FUNCTION  airline#statusline()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline.vim:207
Called 272 times
Total time:   0.004705
 Self time:   0.004705

count  total (s)   self (s)
  272              0.002253   if has_key(s:contexts, a:winnr)
  272              0.001975     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>200_on_stdout_nvim()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 6 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    6              0.000012   if empty(self.stdoutbuffer)
    3              0.000005     let self.stdoutbuffer = a:data
    3              0.000001   else
    3              0.000025     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    6              0.000003   endif

FUNCTION  <SNR>202_TagbarBufName()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:3642
Called 7 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    7              0.000035     if !exists('t:tagbar_buf_name')
                                    let s:buffer_seqno += 1
                                    let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
    7              0.000003     endif
                            
    7              0.000008     return t:tagbar_buf_name

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 6 times
Total time:   0.001634
 Self time:   0.000211

count  total (s)   self (s)
    6   0.001628   0.000205   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>61_abs_path()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 21 times
Total time:   0.001124
 Self time:   0.001124

count  total (s)   self (s)
   21              0.000698   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   21              0.000326   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   21              0.000062   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  bufferline#update_async()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/barbar.nvim/plugin/bufferline.vim:148
Called 3 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000009    let update_names = a:0 > 0 ? a:1 : v:false
    3              0.000004    let delay = a:0 > 1 ? a:2 : 1
    3              0.000028    call timer_start(delay, {->bufferline#update(a:0 > 0 ? a:1 : v:false)})

FUNCTION  airline#extensions#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 10 times
Total time:   0.002096
 Self time:   0.000554

count  total (s)   self (s)
   10              0.000041   let filetype_overrides = get(s:, 'filetype_overrides', {})
   10              0.000050   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
   10   0.001614   0.000072   if s:is_excluded_window()
                                return -1
   10              0.000003   endif
                            
   10              0.000018   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
   10              0.000003   endif
                            
   10              0.000026   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
   10              0.000003   endif
                            
   10              0.000081   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
   10              0.000004   endif
                            
   10              0.000011   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
   10              0.000003   endif
                            
   10              0.000034   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
   10              0.000005   endfor

FUNCTION  yoink#getDefaultReg()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-yoink/autoload/yoink.vim:86
Called 6 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    6              0.000076     let clipboardFlags = split(&clipboard, ',')
    6              0.000015     if index(clipboardFlags, 'unnamedplus') >= 0
                                    return "+"
    6              0.000029     elseif index(clipboardFlags, 'unnamed') >= 0
                                    return "*"
    6              0.000003     else
    6              0.000005         return "\""
                                endif

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:143
Called 272 times
Total time:   0.001767
 Self time:   0.001767

count  total (s)   self (s)
  272              0.000587   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
  272              0.000098   endif
  272              0.000283   return s:has_fugitive

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:158
Called 272 times
Total time:   0.001565
 Self time:   0.001565

count  total (s)   self (s)
  272              0.000628   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
  272              0.000113   endif
  272              0.000286   return s:has_lawrencium

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:205
Called 3 times
Total time:   0.001048
 Self time:   0.000535

count  total (s)   self (s)
    3              0.000005   let hunks = []
   30              0.000081   for line in split(a:diff, '\n')
   27   0.000844   0.000331     let hunk_info = gitgutter#diff#parse_hunk(line)
   27              0.000031     if len(hunk_info) == 4
   27              0.000040       call add(hunks, hunk_info)
   27              0.000010     endif
   30              0.000013   endfor
    3              0.000003   return hunks

FUNCTION  <SNR>209_highlight_name_for_change()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 72 times
Total time:   0.000209
 Self time:   0.000209

count  total (s)   self (s)
   72              0.000070   if a:text ==# 'added'
   51              0.000035     return 'GitGutterLineAdded'
   21              0.000018   elseif a:text ==# 'removed'
   12              0.000008     return 'GitGutterLineRemoved'
    9              0.000009   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
    9              0.000007   elseif a:text ==# 'modified'
    9              0.000006     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  airline#extensions#coc#get_current_function()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:43
Called 272 times
Total time:   0.000826
 Self time:   0.000826

count  total (s)   self (s)
  272              0.000719   return get(b:, 'coc_current_function', '')

FUNCTION  <SNR>164_sh_autocmd_handler()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:46
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000006   if exists('#airline')
    3              0.000007     unlet! b:fugitive_name
    3              0.000001   endif

FUNCTION  <SNR>177_reset_tick()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:166
Called 63 times
Total time:   0.001197
 Self time:   0.000414

count  total (s)   self (s)
   63   0.001173   0.000390   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  airline#extensions#fzf#inactive_apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:37
Called 10 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
   10              0.000036   if getbufvar(a:2.bufnr, '&filetype') ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
   10              0.000004   endif

FUNCTION  <SNR>176_get_section()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 75 times
Total time:   0.002210
 Self time:   0.001757

count  total (s)   self (s)
   75              0.000147   if has_key(s:section_truncate_width, a:key)
   45   0.000556   0.000258     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
   18              0.000011       return ''
   27              0.000009     endif
   57              0.000019   endif
   57              0.000090   let spc = g:airline_symbols.space
   57              0.000174   if !exists('g:airline_section_{a:key}')
                                return ''
   57              0.000018   endif
   57   0.000550   0.000394   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   57              0.000278   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   57              0.000155   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>43_empty_message()
    Defined: ~/.config_stow/nvim/.config/nvim/vim_settings.vim:351
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    2              0.000033   if mode() ==# 'n'
    2              0.000025     echon ''
    2              0.000004   endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 7 times
Total time:   0.001786
 Self time:   0.000201

count  total (s)   self (s)
    7              0.000023     if getbufvar(a:bufnr, '&modified')
                                  let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    7              0.000003     else
    7              0.000060       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    7              0.000003     endif
                            
    7              0.000010     if !empty(colors)
    7   0.001647   0.000062       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    7              0.000003     endif

FUNCTION  47()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/state.vim:41
Called 3 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    3              0.000006     let self._current = a:fileinfo

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:315
Called 272 times
Total time:   0.235473
 Self time:   0.008990

count  total (s)   self (s)
  272   0.220786   0.001520   let head = airline#extensions#branch#head()
  272   0.003126   0.002124   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  272              0.000824   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  272   0.007759   0.001544   let head = airline#util#shorten(head, winwidth, minwidth)
  272              0.000865   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  272              0.001728   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:42
Called 272 times
Total time:   0.007412
 Self time:   0.001669

count  total (s)   self (s)
  272   0.007302   0.001559   return airline#extensions#nvimlsp#get('Error')

FUNCTION  bufferline#update()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/barbar.nvim/plugin/bufferline.vim:136
Called 6 times
Total time:   0.009192
 Self time:   0.000158

count  total (s)   self (s)
    6              0.000014    if get(g:, 'SessionLoad')
                                  return
    6              0.000002    endif
    6   0.009075   0.000041    let new_value = bufferline#render(a:0 > 0 ? a:1 : v:false)
    6              0.000085    if new_value == s:last_tabline
    6              0.000004       return
                               end
                               let &tabline = new_value
                               let s:last_tabline = new_value

FUNCTION  coc#rpc#notify()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim:96
Called 177 times
Total time:   0.018738
 Self time:   0.002665

count  total (s)   self (s)
  177   0.001971   0.000781   if !coc#rpc#ready()
                                return ''
  177              0.000064   endif
  177   0.016267   0.001384   call s:client['notify'](a:method, a:args)
  177              0.000156   return ''

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 272 times
Total time:   0.058005
 Self time:   0.029179

count  total (s)   self (s)
  272              0.000685   if !get(w:, 'airline_active', 0)
                                return ''
  272              0.000557   endif
                              " Cache values, so that it isn't called too often
  272   0.006802   0.004806   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
  272              0.000115   endif
  272   0.020935   0.001767   let hunks = airline#extensions#hunks#get_raw_hunks()
  272              0.000271   let string = ''
  272   0.002746   0.001817   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  272              0.000405   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
 1072              0.001431     for i in [0, 1, 2]
  804   0.009269   0.004540       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  804              0.003408         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  804              0.000363       endif
 1072              0.000622     endfor
  272              0.000112   endif
  272   0.002946   0.002418   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
  272              0.000111   endif
                            
  272              0.000410   let b:airline_hunks = string
  272              0.000429   let b:airline_changenr = b:changedtick
  272   0.002654   0.001180   let s:airline_winwidth = airline#util#winwidth()
  272              0.000237   return string

FUNCTION  <SNR>175_section_is_empty()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 71 times
Total time:   0.000463
 Self time:   0.000463

count  total (s)   self (s)
   71              0.000078   let start=1
                            
                              " do not check for inactive windows or the tabline
   71              0.000091   if a:self._context.active == 0
   44              0.000033     return 0
   27              0.000052   elseif get(a:self._context, 'tabline', 0)
                                return 0
   27              0.000010   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   27              0.000047   if get(g:, 'airline_skip_empty_sections', 0) == 0
   27              0.000015     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  yoink#onFocusGained()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-yoink/autoload/yoink.vim:460
Called 3 times
Total time:   0.000155
 Self time:   0.000067

count  total (s)   self (s)
    3              0.000012     if len(s:focusLostInfo) == 0
                                    return
    3              0.000001     endif
                            
    3   0.000108   0.000020     let defaultReg = yoink#getDefaultReg()
                            
    3              0.000006     if defaultReg ==# '*' || defaultReg == '+'
                                    let entry = yoink#getDefaultYankInfo()
                            
                                    if s:focusLostInfo != entry
                                        " User copied something outside of vim
                                        call yoink#addCurrentDefaultRegToHistory()
                                    endif
    3              0.000001     endif

FUNCTION  <SNR>204_GitDir()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/autoload/fugitive.vim:494
Called 544 times
Total time:   0.024734
 Self time:   0.003099

count  total (s)   self (s)
  544   0.024566   0.002930   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000004   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    3              0.000001   endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 325 times
Total time:   0.003396
 Self time:   0.003396

count  total (s)   self (s)
  325              0.001098   let ggvars = getbufvar(a:buffer, 'gitgutter')
  325              0.001338   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
  319              0.000591     return ggvars[a:varname]
    6              0.000004   endif
    6              0.000006   if a:0
    6              0.000007     return a:1
                              endif

FUNCTION  FugitiveParse()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:89
Called 4 times
Total time:   0.000052
 Self time:   0.000045

count  total (s)   self (s)
    4   0.000031   0.000025   let path = s:Slash(a:0 ? a:1 : @%)
    4              0.000012   if path !~# '^fugitive:'
    4              0.000004     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  <SNR>61_winshell()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000017   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>216_isFolded()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar/prototypes/basetag.vim:156
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005     return self.fileinfo.tagfolds[self.fields.kind][self.fullpath]

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:64
Called 3 times
Total time:   0.000649
 Self time:   0.000649

count  total (s)   self (s)
    3              0.000648     let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:63
Called 1904 times
Total time:   0.010445
 Self time:   0.010445

count  total (s)   self (s)
 1904              0.003447   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1904              0.000696   endif
 1904              0.004387   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>167_ws_refresh()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:186
Called 3 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000015   if !exists('#airline')
                                " airline disabled
                                return
    3              0.000002   endif
    3              0.000016   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    3              0.000003     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>75_Autocmd()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/coc.nvim/plugin/coc.vim:245
Called 174 times
Total time:   0.019887
 Self time:   0.001577

count  total (s)   self (s)
  174              0.000262   if !g:coc_service_initialized
                                return
  174              0.000067   endif
  174   0.019276   0.000966   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  airline#util#getbufvar()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:71
Called 16 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   16              0.000035     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>161_is_branch_empty()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 272 times
Total time:   0.001611
 Self time:   0.001611

count  total (s)   self (s)
  272              0.001432   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>61_is_file_buffer()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 6 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    6              0.000036   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>202_GetNearbyTag()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/tagbar/autoload/tagbar.vim:3165
Called 31 times
Total time:   0.013304
 Self time:   0.012337

count  total (s)   self (s)
   31              0.000032     if s:nearby_disabled
                                    return {}
   31              0.000010     endif
                            
   31   0.000939   0.000212     let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
   31              0.000043     if empty(fileinfo)
                                    return {}
   31              0.000010     endif
                            
   31              0.000085     let curline = a:0 > 0 ? a:1 : line('.')
   31              0.000052     let direction = a:0 > 1 ? a:2 : -1
   31              0.000046     let ignore_curline = a:0 > 2 ? a:3 : 0
                            
   31              0.000047     let typeinfo = fileinfo.typeinfo
   31              0.000039     let tag = {}
                            
   31              0.000031     if direction < 0
   31              0.000033         let endline = 1
   31              0.000031         let increment = -1
                                else
                                    let endline = line('$')
                                    let increment = 1
   31              0.000011     endif
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
  948              0.000828     for line in range(curline, endline, increment)
  948              0.001240         if has_key(fileinfo.fline, line)
   31              0.000061             let curtag = fileinfo.fline[line]
   31   0.000513   0.000273             if a:request ==# 'nearest-stl' && typeinfo.getKind(curtag.fields.kind).stl
   31              0.000039                 let tag = curtag
   31              0.000020                 break
                                        elseif a:request ==# 'scoped-stl' && typeinfo.getKind(curtag.fields.kind).stl && curtag.fields.line <= curline && curline <= curtag.fields.end
                                            let tag = curtag
                                            break
                                        elseif a:request ==# 'nearest' || (line == curline && ignore_curline == 0)
                                            let tag = curtag
                                            break
                                        endif
  917              0.000256         endif
  948              0.000418     endfor
                            
   31              0.000028     return tag

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 3 times
Total time:   0.000177
 Self time:   0.000046

count  total (s)   self (s)
    3   0.000097   0.000020   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    3   0.000076   0.000024   call s:reset_summary(a:bufnr)

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:505
Called 272 times
Total time:   0.000528
 Self time:   0.000528

count  total (s)   self (s)
  272              0.000404   return s:loaded_ext

FUNCTION  airline#builder#new()
    Defined: ~/.config_stow/nvim/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 16 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
   16              0.000108   let builder = copy(s:prototype)
   16              0.000028   let builder._context = a:context
   16              0.000021   let builder._sections = []
                            
   16              0.000205   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   16              0.000030   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  272   0.235473   0.008990  airline#extensions#branch#get_head()
  272   0.219266   0.006960  airline#extensions#branch#head()
  272   0.187602   0.012023  <SNR>163_update_branch()
  272   0.161068   0.006233  <SNR>163_update_git_branch()
  272   0.150897   0.005558  <SNR>163_config_fugitive_branch()
  272   0.143367   0.009188  FugitiveHead()
  272   0.122826   0.015570  fugitive#Head()
  272   0.107692   0.032352  airline#check_mode()
  272   0.107256   0.055050  fugitive#Find()
    7   0.071322   0.009924  airline#highlighter#highlight()
  551   0.066839   0.029959  airline#highlighter#get_highlight()
    3   0.062536   0.000068  <SNR>47_on_focus_gained()
    3   0.062426   0.000435  <SNR>47_airline_refresh()
    3   0.060766   0.000231  airline#update_statusline()
   13   0.059614   0.000630  <SNR>155_invoke_funcrefs()
  269   0.058103   0.020869  airline#highlighter#exec()
  272   0.058005   0.029179  airline#extensions#hunks#get_hunks()
  103   0.056249   0.003774  <SNR>160_exec_separator()
   13   0.055813   0.008310  40()
 1088   0.043304   0.041936  FugitiveGitDir()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  272   0.107256   0.055050  fugitive#Find()
 1088   0.043304   0.041936  FugitiveGitDir()
 2204              0.034273  <SNR>160_get_syn()
  272   0.107692   0.032352  airline#check_mode()
  551   0.066839   0.029959  airline#highlighter#get_highlight()
  272   0.058005   0.029179  airline#extensions#hunks#get_hunks()
    3   0.029696   0.027685  <SNR>202_HighlightTag()
  272   0.032980   0.026957  airline#extensions#whitespace#check()
 3569              0.024206  airline#util#winwidth()
  272   0.024466   0.021289  <SNR>163_update_untracked()
  269   0.058103   0.020869  airline#highlighter#exec()
    3   0.016922   0.016825  gitgutter#async#execute()
 1088   0.024772   0.016096  airline#util#shorten()
  544              0.015879  airline#extensions#nvimlsp#get()
  272   0.122826   0.015570  fugitive#Head()
  544              0.015478  airline#extensions#coc#get()
 3264   0.018353   0.015308  airline#util#wrap()
 1904              0.015076  airline#util#append()
  177   0.014883   0.013960  <SNR>78_notify()
  272   0.014511   0.012947  <SNR>163_update_hg_branch()

