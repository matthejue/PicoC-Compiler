# File 'nested_loops' Start
# Main Funktion '(void main (int x) ... )' Start
LOADI SP 200;
# Allokation '(int x)' Start
# Variable 'x' vom Typ 'int' mit Adresse '100' zur Symboltabelle hinzugefügt
# Allokation '(int x)' Ende
# Zuweisung '((const char y) = 71)' Start
# Allokation '(const char y)' Start
# Konstante 'y' vom Typ 'char' zur Symboltabelle hinzugefügt
# Allokation '(const char y)' Ende
# Konstante 'y' in Symboltabelle den Wert '71' zugewiesen
# Zuweisung '((const char y) = 71)' Ende
# Zuweisung '((int z) = y)' Start
# Allokation '(int z)' Start
# Variable 'z' vom Typ 'int' mit Adresse '101' zur Symboltabelle hinzugefügt
# Allokation '(int z)' Ende
# Arithmetischer Operand 'y' Start
SUBI SP 1;                             # Stack um eine Zelle erweitern
LOADI ACC 71;                          # Wert von 'y' in ACC laden
STOREIN SP ACC 1;                      # Wert in oberste Stack-Zelle
# Arithmetischer Operand 'y' Ende
LOADIN SP ACC 1;                       # Wert von 'y' in ACC laden
ADDI SP 1;                             # Stack um eine Zelle verkürzen
STORE ACC 101;                         # Wert 'y' in Variable 'z' speichern
# Zuweisung '((int z) = y)' Ende
# While Statement 'While((x <= 42) While((y <= 42) (z = (x & y))))' Start
# Logisches Atom '(x <= 42)' Start
# Arithmetischer Operand 'x' Start
SUBI SP 1;                             # Stack um eine Zelle erweitern
LOAD ACC 100;                          # Wert von 'x' in ACC laden
STOREIN SP ACC 1;                      # Wert in oberste Stack-Zelle
# Arithmetischer Operand 'x' Ende
# Arithmetischer Operand '42' Start
SUBI SP 1;                             # Stack um eine Zelle erweitern
LOADI ACC 42;                          # Wert von '42' in ACC laden
STOREIN SP ACC 1;                      # Wert in oberste Stack-Zelle
# Arithmetischer Operand '42' Ende
LOADIN SP ACC 2;                       # Wert von 'x' in ACC laden
LOADIN SP IN2 1;                       # Wert von '42' in IN2 laden
SUB ACC IN2;                           # 'x - 42' in ACC laden
JUMP<= 3;                              # Ergebnis '1', wenn '(x <= 42)' erfüllt
LOADI ACC 0;                           # Ergebnis '0', wenn '(x <= 42)' nicht erfüllt
JUMP 2;
LOADI ACC 1;                           # Ergebnis '1', wenn '(x <= 42)' wahr
STOREIN SP ACC 2;                      # Ergebnis in zweitoberste Stack-Zelle
ADDI SP 1;                             # Stack um eine Zelle verkürzen
# Logisches Atom '(x <= 42)' Ende
LOADIN SP ACC 1;                       # Wert von '(x <= 42)' in ACC laden
ADDI SP 1;                             # Stack um eine Zelle verkürzen
JUMP== 35;                             # Statements überspringen, wenn '(x <= 42)' nicht erfüllt
# While Statement 'While((y <= 42) (z = (x & y)))' Start
# Logisches Atom '(y <= 42)' Start
# Arithmetischer Operand 'y' Start
SUBI SP 1;                             # Stack um eine Zelle erweitern
LOADI ACC 71;                          # Wert von 'y' in ACC laden
STOREIN SP ACC 1;                      # Wert in oberste Stack-Zelle
# Arithmetischer Operand 'y' Ende
# Arithmetischer Operand '42' Start
SUBI SP 1;                             # Stack um eine Zelle erweitern
LOADI ACC 42;                          # Wert von '42' in ACC laden
STOREIN SP ACC 1;                      # Wert in oberste Stack-Zelle
# Arithmetischer Operand '42' Ende
LOADIN SP ACC 2;                       # Wert von 'y' in ACC laden
LOADIN SP IN2 1;                       # Wert von '42' in IN2 laden
SUB ACC IN2;                           # 'y - 42' in ACC laden
JUMP<= 3;                              # Ergebnis '1', wenn '(y <= 42)' erfüllt
LOADI ACC 0;                           # Ergebnis '0', wenn '(y <= 42)' nicht erfüllt
JUMP 2;
LOADI ACC 1;                           # Ergebnis '1', wenn '(y <= 42)' wahr
STOREIN SP ACC 2;                      # Ergebnis in zweitoberste Stack-Zelle
ADDI SP 1;                             # Stack um eine Zelle verkürzen
# Logisches Atom '(y <= 42)' Ende
LOADIN SP ACC 1;                       # Wert von '(y <= 42)' in ACC laden
ADDI SP 1;                             # Stack um eine Zelle verkürzen
JUMP== 16;                             # Statements überspringen, wenn '(y <= 42)' nicht erfüllt
# Zuweisung '(z = (x & y))' Start
# Arithmetische binäre Operation '(x & y)' Start
# Arithmetischer Operand 'x' Start
SUBI SP 1;                             # Stack um eine Zelle erweitern
LOAD ACC 100;                          # Wert von 'x' in ACC laden
STOREIN SP ACC 1;                      # Wert in oberste Stack-Zelle
# Arithmetischer Operand 'x' Ende
# Arithmetischer Operand 'y' Start
SUBI SP 1;                             # Stack um eine Zelle erweitern
LOADI ACC 71;                          # Wert von 'y' in ACC laden
STOREIN SP ACC 1;                      # Wert in oberste Stack-Zelle
# Arithmetischer Operand 'y' Ende
LOADIN SP ACC 2;                       # Wert von 'x' in ACC laden
LOADIN SP IN2 1;                       # Wert von 'y' in IN2 laden
AND ACC IN2;                           # Wert von '(x & y)' in ACC laden
STOREIN SP ACC 2;                      # Ergebnis in zweitoberste Stack-Zelle
ADDI SP 1;                             # Stack um eine Zelle verkürzen
# Arithmetische binäre Operation '(x & y)' Ende
LOADIN SP ACC 1;                       # Wert von '(x & y)' in ACC laden
ADDI SP 1;                             # Stack um eine Zelle verkürzen
STORE ACC 101;                         # Wert '(x & y)' in Variable 'z' speichern
# Zuweisung '(z = (x & y))' Ende
JUMP -32;                              # Zurück zur Auswertung von '(y <= 42)'
# While Statement 'While((y <= 42) (z = (x & y)))' Ende
JUMP -51;                              # Zurück zur Auswertung von '(x <= 42)'
# While Statement 'While((x <= 42) While((y <= 42) (z = (x & y))))' Ende
JUMP 0;
# Main Funktion '(void main (int x) ... )' Ende
# File 'nested_loops' Ende
