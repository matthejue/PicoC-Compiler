!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/areo/Documents/Studium/pico-c-compiler/src/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210110.0/
ASTBuilder	ast_builder.py	/^class ASTBuilder():$/;"	c
ASTNode	abstract_syntax_tree.py	/^class ASTNode:$/;"	c
ArithmeticExpressionGrammer	arithmetic_expression.py	/^class ArithmeticExpressionGrammer(Parser):$/;"	c
BINOP_PREC_1	lexer.py	/^    BINOP_PREC_1 = "binary operator with precedence 1"$/;"	v	class:TT
BINOP_PREC_2	lexer.py	/^    BINOP_PREC_2 = "binary operator with precedence 2"$/;"	v	class:TT
DIGIT_WITHOUT_ZERO	lexer.py	/^    DIGIT_WITHOUT_ZERO = "123456789"$/;"	v	class:Lexer
DIGIT_WITH_ZERO	lexer.py	/^    DIGIT_WITH_ZERO = "0123456789"$/;"	v	class:Lexer
EOF	lexer.py	/^    EOF = "EOF"$/;"	v	class:TT
EOF_CHAR	lexer.py	/^    EOF_CHAR = "EOF"$/;"	v	class:Lexer
EQUALS	lexer.py	/^    EQUALS = "="$/;"	v	class:TT
IDENTIFIER	lexer.py	/^    IDENTIFIER = "identifier"$/;"	v	class:TT
InvalidCharacterError	errors.py	/^class InvalidCharacterError(Exception):$/;"	c
LETTER	lexer.py	/^    LETTER = string.ascii_letters$/;"	v	class:Lexer
LETTER_DIGIT	lexer.py	/^    LETTER_DIGIT = LETTER + DIGIT_WITH_ZERO + '_'$/;"	v	class:Lexer
LT	parser.py	/^    def LT(self, i):$/;"	m	class:Parser
LTT	parser.py	/^    def LTT(self, i):$/;"	m	class:Parser
L_PAREN	lexer.py	/^    L_PAREN = "("$/;"	v	class:TT
Lexer	lexer.py	/^class Lexer:$/;"	c
MINUS	lexer.py	/^    MINUS = "-"$/;"	v	class:TT
NUMBER	lexer.py	/^    NUMBER = "number"$/;"	v	class:TT
Parser	parser.py	/^class Parser:$/;"	c
R_PAREN	lexer.py	/^    R_PAREN = ")"$/;"	v	class:TT
SEMICOLON	lexer.py	/^    SEMICOLON = ";"$/;"	v	class:TT
SyntaxError	errors.py	/^class SyntaxError(Exception):$/;"	c
TT	lexer.py	/^class TT(Enum):$/;"	c
Token	lexer.py	/^class Token():$/;"	c
UNOP	lexer.py	/^    UNOP = "unary operator"$/;"	v	class:TT
__init__	abstract_syntax_tree.py	/^    def __init__(self, token):$/;"	m	class:ASTNode
__init__	arithmetic_expression.py	/^    def __init__(self, lexer, num_lts):$/;"	m	class:ArithmeticExpressionGrammer
__init__	ast_builder.py	/^    def __init__(self, lexer, num_lts):$/;"	m	class:ASTBuilder
__init__	errors.py	/^    def __init__(self, expected, found):$/;"	m	class:SyntaxError
__init__	errors.py	/^    def __init__(self, found):$/;"	m	class:InvalidCharacterError
__init__	lexer.py	/^    def __init__(self, fname, input):$/;"	m	class:Lexer
__init__	lexer.py	/^    def __init__(self, type, value):$/;"	m	class:Token
__init__	parser.py	/^    def __init__(self, lexer, num_lts):$/;"	m	class:Parser
__repr__	abstract_syntax_tree.py	/^    def __repr__(self):$/;"	m	class:ASTNode
__repr__	lexer.py	/^    def __repr__(self):$/;"	m	class:Token
_ao	arithmetic_expression.py	/^    def _ao(self):$/;"	m	class:ArithmeticExpressionGrammer
_identifier	lexer.py	/^    def _identifier(self):$/;"	m	class:Lexer
_number	lexer.py	/^    def _number(self):$/;"	m	class:Lexer
_paren	arithmetic_expression.py	/^    def _paren(self):$/;"	m	class:ArithmeticExpressionGrammer
_prec1	arithmetic_expression.py	/^    def _prec1(self):$/;"	m	class:ArithmeticExpressionGrammer
_prec2	arithmetic_expression.py	/^    def _prec2(self):$/;"	m	class:ArithmeticExpressionGrammer
_unop	arithmetic_expression.py	/^    def _unop(self, ):$/;"	m	class:ArithmeticExpressionGrammer
addChild	abstract_syntax_tree.py	/^    def addChild(self, t):$/;"	m	class:ASTNode
args	pico_c_compiler.py	/^args = None$/;"	v
code_ae	arithmetic_expression.py	/^    def code_ae(self):$/;"	m	class:ArithmeticExpressionGrammer
compile	pico_c_compiler.py	/^def compile(fname, code):$/;"	f
down	ast_builder.py	/^    def down(self, match_tok, cls, token):$/;"	m	class:ASTBuilder
getNodeType	abstract_syntax_tree.py	/^    def getNodeType(self):$/;"	m	class:ASTNode
isEmpty	abstract_syntax_tree.py	/^    def isEmpty(self):$/;"	m	class:ASTNode
main	pico_c_compiler.py	/^def main():$/;"	f
match	ast_builder.py	/^    def match(self, tt):$/;"	m	class:ASTBuilder
match	lexer.py	/^    def match(self, m):$/;"	m	class:Lexer
match	parser.py	/^    def match(self, tt):$/;"	m	class:Parser
next_char	lexer.py	/^    def next_char(self):$/;"	m	class:Lexer
next_token	lexer.py	/^    def next_token(self):$/;"	m	class:Lexer
next_token	parser.py	/^    def next_token(self):$/;"	m	class:Parser
shell	pico_c_compiler.py	/^def shell():$/;"	f
up	ast_builder.py	/^    def up(self, savestate_node):$/;"	m	class:ASTBuilder
