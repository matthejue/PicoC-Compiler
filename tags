!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/areo/Documents/Studium/pico_c_compiler/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210905.0/
ALLOC	src/lexer.py	/^    ALLOC = "allocation"$/;"	v	class:TT
AND	src/lexer.py	/^    AND = "and logical expression grammar"$/;"	v	class:TT
AND_OP	src/lexer.py	/^    AND_OP = "and arithmetic operator"$/;"	v	class:TT
ASSIGNMENT	src/lexer.py	/^    ASSIGNMENT = "assignment operator"$/;"	v	class:TT
ASTBuilder	src/ast_builder.py	/^class ASTBuilder:$/;"	c
ASTNode	src/abstract_syntax_tree.py	/^class ASTNode(TokenNode):$/;"	c
AllocationNode	src/abstract_syntax_tree.py	/^class AllocationNode(ASTNode):$/;"	c
Args	test/grammar_test.py	/^class Args(object):$/;"	c
ArithmeticBinaryOperationNode	src/abstract_syntax_tree.py	/^class ArithmeticBinaryOperationNode(ASTNode):$/;"	c
ArithmeticExpressionGrammar	src/arithmetic_expression_grammar.py	/^class ArithmeticExpressionGrammar(BacktrackingParser):$/;"	c
ArithmeticUnaryOperationNode	src/abstract_syntax_tree.py	/^class ArithmeticUnaryOperationNode(ASTNode):$/;"	c
ArithmeticVariableConstantNode	src/abstract_syntax_tree.py	/^class ArithmeticVariableConstantNode(ASTNode):$/;"	c
AssignmentAllocationGrammar	src/assignment_allocation_grammar.py	/^class AssignmentAllocationGrammar(LogicExpressionGrammar):$/;"	c
AssignmentNode	src/abstract_syntax_tree.py	/^class AssignmentNode(ASTNode):$/;"	c
BINOP_PREC_1	src/lexer.py	/^    BINOP_PREC_1 = "binary operator with precedence 1"$/;"	v	class:TT
BINOP_PREC_2	src/lexer.py	/^    BINOP_PREC_2 = "binary operator with precedence 2"$/;"	v	class:TT
BITSHIFT	src/lexer.py	/^    BITSHIFT = "bitshift"$/;"	v	class:TT
BacktrackingParser	src/parser_.py	/^class BacktrackingParser():$/;"	c
BuiltInTypeSymbol	src/symbol_table.py	/^class BuiltInTypeSymbol(Symbol):$/;"	c
COMP_OP	src/lexer.py	/^    COMP_OP = "comparison operator"$/;"	v	class:TT
COMP_OPERATOR_ASSIGNMENT_BITSHIFT	src/lexer.py	/^    COMP_OPERATOR_ASSIGNMENT_BITSHIFT = ['=', '<', '>']$/;"	v	class:Lexer
CONST	src/lexer.py	/^    CONST = "constant qualifier"$/;"	v	class:TT
CodeGenerator	src/code_generator.py	/^def CodeGenerator():$/;"	f
ConstantSymbol	src/symbol_table.py	/^class ConstantSymbol(Symbol):$/;"	c
DIGIT_WITHOUT_ZERO	src/lexer.py	/^    DIGIT_WITHOUT_ZERO = "123456789"$/;"	v	class:Lexer
DIGIT_WITH_ZERO	src/lexer.py	/^    DIGIT_WITH_ZERO = "0123456789"$/;"	v	class:Lexer
DO_WHILE	src/lexer.py	/^    DO_WHILE = "do while statement"$/;"	v	class:TT
Debug	.vimspector.json	/^    "Debug": {$/;"	o	object:configurations
DoWhileNode	src/abstract_syntax_tree.py	/^class DoWhileNode(ASTNode):$/;"	c
ELSE	src/lexer.py	/^    ELSE = "else statement"$/;"	v	class:TT
EOF	src/lexer.py	/^    EOF = "end of file"$/;"	v	class:TT
EOF_CHAR	src/lexer.py	/^    EOF_CHAR = "EOF"$/;"	v	class:Lexer
ErrorHandler	src/errors.py	/^class ErrorHandler:$/;"	c
FUNCTION	src/lexer.py	/^    FUNCTION = "function"$/;"	v	class:TT
FunctionGrammar	src/function_grammar.py	/^class FunctionGrammar(StatementSequenceGrammar):$/;"	c
Grammar	src/grammar.py	/^class Grammar(FunctionGrammar):$/;"	c
IDENTIFIER	src/lexer.py	/^    IDENTIFIER = "identifier"$/;"	v	class:TT
IF	src/lexer.py	/^    IF = "if statement"$/;"	v	class:TT
IfElseNode	src/abstract_syntax_tree.py	/^class IfElseNode(ASTNode):$/;"	c
IfNode	src/abstract_syntax_tree.py	/^class IfNode(ASTNode):$/;"	c
InvalidCharacterError	src/errors.py	/^class InvalidCharacterError(Exception):$/;"	c
LETTER	src/lexer.py	/^    LETTER = string.ascii_letters$/;"	v	class:Lexer
LETTER_DIGIT	src/lexer.py	/^    LETTER_DIGIT = LETTER + DIGIT_WITH_ZERO + '_'$/;"	v	class:Lexer
LT	src/parser_.py	/^    def LT(self, i):$/;"	m	class:BacktrackingParser
LTT	src/parser_.py	/^    def LTT(self, i):$/;"	m	class:BacktrackingParser
L_BRACE	src/lexer.py	/^    L_BRACE = "left brace"$/;"	v	class:TT
L_PAREN	src/lexer.py	/^    L_PAREN = "left parenthesis"$/;"	v	class:TT
Lexer	src/lexer.py	/^class Lexer:$/;"	c
LogicAndOrNode	src/abstract_syntax_tree.py	/^class LogicAndOrNode(ASTNode):$/;"	c
LogicAtomNode	src/abstract_syntax_tree.py	/^class LogicAtomNode(ASTNode):$/;"	c
LogicExpressionGrammar	src/logic_expression_grammar.py	/^class LogicExpressionGrammar(ArithmeticExpressionGrammar):$/;"	c
LogicNotNode	src/abstract_syntax_tree.py	/^class LogicNotNode(ASTNode):$/;"	c
LogicTopBottomNode	src/abstract_syntax_tree.py	/^class LogicTopBottomNode(ASTNode):$/;"	c
MAIN	src/lexer.py	/^    MAIN = "main function"$/;"	v	class:TT
MINUS	src/lexer.py	/^    MINUS = "minus unary or binary operator"$/;"	v	class:TT
MainFunctionNode	src/abstract_syntax_tree.py	/^class MainFunctionNode(ASTNode):$/;"	c
MismatchedTokenError	src/errors.py	/^class MismatchedTokenError(Exception):$/;"	c
NOT	src/lexer.py	/^    NOT = "not logical expression grammar"$/;"	v	class:TT
NUMBER	src/lexer.py	/^    NUMBER = "number"$/;"	v	class:TT
NoApplicableRuleError	src/errors.py	/^class NoApplicableRuleError(Exception):$/;"	c
OR	src/lexer.py	/^    OR = "or logical expression grammar"$/;"	v	class:TT
OR_OP	src/lexer.py	/^    OR_OP = "or arithmetic operator"$/;"	v	class:TT
PRIM_DT	src/lexer.py	/^    PRIM_DT = "primitive datatype"$/;"	v	class:TT
Pico-C Compiler	README.md	/^# Pico-C Compiler$/;"	c
R_BRACE	src/lexer.py	/^    R_BRACE = "right brace"$/;"	v	class:TT
R_PAREN	src/lexer.py	/^    R_PAREN = "right parenthesis"$/;"	v	class:TT
SEMICOLON	src/lexer.py	/^    SEMICOLON = "semicolon"$/;"	v	class:TT
STATEMENT	src/lexer.py	/^    STATEMENT = "statement"$/;"	v	class:TT
Scope	src/symbol_table.py	/^class Scope:$/;"	c
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
SessionLoad	test/Session.vim	/^let SessionLoad = 1$/;"	v
StatementSequenceGrammar	src/statement_sequence_grammar.py	/^class StatementSequenceGrammar(AssignmentAllocationGrammar):$/;"	c
Symbol	src/symbol_table.py	/^class Symbol:$/;"	c
SymbolTable	src/symbol_table.py	/^def SymbolTable():$/;"	f
SyntaxError	src/errors.py	/^class SyntaxError(Exception):$/;"	c
TEST_BINARY_BASENAMES	Makefile	/^TEST_BINARY_BASENAMES = $(shell basename -a $(wildcard .\/test\/*_test.py))$/;"	m
TEST_BINARY_PATHS	Makefile	/^TEST_BINARY_PATHS = $(foreach test_binary,$(TEST_BINARY_BASENAMES),test\/$(test_binary))$/;"	m
TODO	README.md	/^## TODO$/;"	s	chapter:Pico-C Compiler
TO_BOOL	src/lexer.py	/^    TO_BOOL = "convert to boolean value"$/;"	v	class:TT
TT	src/lexer.py	/^class TT(Enum):$/;"	c
TestArithmeticExpreessions	.misc/test_parser	/^class TestArithmeticExpreessions(unittest.TestCase):$/;"	c
TestArithmeticExpressionGrammar	test/grammar_test.py	/^class TestArithmeticExpressionGrammar(unittest.TestCase, UsefullTools):$/;"	c
TestAssignmentGrammar	test/grammar_test.py	/^class TestAssignmentGrammar(unittest.TestCase, UsefullTools):$/;"	c
TestCodeGenerator	test/grammar_test.py	/^class TestCodeGenerator(unittest.TestCase, UsefullTools):$/;"	c
TestComments	test/grammar_test.py	/^class TestComments(unittest.TestCase, UsefullTools):$/;"	c
TestError	test/grammar_test.py	/^class TestError(unittest.TestCase, UsefullTools):$/;"	c
TestErrors	.misc/test_errors	/^class TestErrors(unittest.TestCase):$/;"	c
TestIfElseGrammar	test/grammar_test.py	/^class TestIfElseGrammar(unittest.TestCase, UsefullTools):$/;"	c
TestLexer	test/grammar_test.py	/^class TestLexer(unittest.TestCase, UsefullTools):$/;"	c
TestLogicExpressionGrammar	test/grammar_test.py	/^class TestLogicExpressionGrammar(unittest.TestCase, UsefullTools):$/;"	c
TestLoopGrammar	test/grammar_test.py	/^class TestLoopGrammar(unittest.TestCase, UsefullTools):$/;"	c
TestPrograms	test/grammar_test.py	/^class TestPrograms(unittest.TestCase, UsefullTools):$/;"	c
Token	src/lexer.py	/^class Token():$/;"	c
TokenNode	src/abstract_syntax_tree.py	/^class TokenNode:$/;"	c
UNARY_OP	src/lexer.py	/^    UNARY_OP = "unary operator"$/;"	v	class:TT
Usage	README.md	/^## Usage$/;"	s	chapter:Pico-C Compiler
Used Resources	README.md	/^## Used Resources$/;"	s	chapter:Pico-C Compiler
UsefullTools	test/grammar_test.py	/^class UsefullTools():$/;"	c
VAR	src/lexer.py	/^    VAR = "variable qualifier"$/;"	v	class:TT
VariableSymbol	src/symbol_table.py	/^class VariableSymbol(Symbol):$/;"	c
WHILE	src/lexer.py	/^    WHILE = "while statement"$/;"	v	class:TT
WhileNode	src/abstract_syntax_tree.py	/^class WhileNode(ASTNode):$/;"	c
_CodeGenerator	src/code_generator.py	/^class _CodeGenerator:$/;"	c
_SymbolTable	src/symbol_table.py	/^class _SymbolTable(Scope):$/;"	c
__init__	src/abstract_syntax_tree.py	/^    def __init__(self, token):$/;"	m	class:TokenNode
__init__	src/abstract_syntax_tree.py	/^    def __init__(self, tokentypes):$/;"	m	class:ASTNode
__init__	src/arithmetic_expression_grammar.py	/^    def __init__(self, lexer):$/;"	m	class:ArithmeticExpressionGrammar
__init__	src/assignment_allocation_grammar.py	/^    def __init__(self, lexer):$/;"	m	class:AssignmentAllocationGrammar
__init__	src/ast_builder.py	/^    def __init__(self):$/;"	m	class:ASTBuilder
__init__	src/code_generator.py	/^    def __init__(self):$/;"	m	class:_CodeGenerator
__init__	src/errors.py	/^    def __init__(self, expected, found):$/;"	m	class:MismatchedTokenError
__init__	src/errors.py	/^    def __init__(self, expected, found):$/;"	m	class:NoApplicableRuleError
__init__	src/errors.py	/^    def __init__(self, expected, found):$/;"	m	class:SyntaxError
__init__	src/errors.py	/^    def __init__(self, found):$/;"	m	class:InvalidCharacterError
__init__	src/errors.py	/^    def __init__(self, grammar):$/;"	m	class:ErrorHandler
__init__	src/function_grammar.py	/^    def __init__(self, lexer):$/;"	m	class:FunctionGrammar
__init__	src/grammar.py	/^    def __init__(self, lexer):$/;"	m	class:Grammar
__init__	src/lexer.py	/^    def __init__(self, fname, input):$/;"	m	class:Lexer
__init__	src/lexer.py	/^    def __init__(self, type, value, position):$/;"	m	class:Token
__init__	src/logic_expression_grammar.py	/^    def __init__(self, lexer):$/;"	m	class:LogicExpressionGrammar
__init__	src/parser_.py	/^    def __init__(self, lexer):$/;"	m	class:BacktrackingParser
__init__	src/statement_sequence_grammar.py	/^    def __init__(self, lexer):$/;"	m	class:StatementSequenceGrammar
__init__	src/symbol_table.py	/^    def __init__(self):$/;"	m	class:_SymbolTable
__init__	src/symbol_table.py	/^    def __init__(self, ):$/;"	m	class:Scope
__init__	src/symbol_table.py	/^    def __init__(self, name):$/;"	m	class:BuiltInTypeSymbol
__init__	src/symbol_table.py	/^    def __init__(self, name, type):$/;"	m	class:VariableSymbol
__init__	src/symbol_table.py	/^    def __init__(self, name, type, value):$/;"	m	class:ConstantSymbol
__init__	src/symbol_table.py	/^    def __init__(self, name, type, value):$/;"	m	class:Symbol
__init__	test/grammar_test.py	/^    def __init__(self):$/;"	m	class:Args
__repr__	src/abstract_syntax_tree.py	/^    def __repr__(self):$/;"	m	class:ASTNode
__repr__	src/abstract_syntax_tree.py	/^    def __repr__(self):$/;"	m	class:TokenNode
__repr__	src/abstract_syntax_tree.py	/^    def __repr__(self, ):$/;"	m	class:AllocationNode
__repr__	src/lexer.py	/^    def __repr__(self):$/;"	m	class:Token
__repr__	src/symbol_table.py	/^    def __repr__(self, ):$/;"	m	class:Symbol
__repr__	src/symbol_table.py	/^    def __repr__(self, ):$/;"	m	class:_SymbolTable
_aa	src/assignment_allocation_grammar.py	/^    def _aa(self):$/;"	m	class:AssignmentAllocationGrammar
_alloc	src/assignment_allocation_grammar.py	/^    def _alloc(self):$/;"	m	class:AssignmentAllocationGrammar
_and	src/lexer.py	/^    def _and(self):$/;"	m	class:Lexer
_and_expr	src/logic_expression_grammar.py	/^    def _and_expr(self):$/;"	m	class:LogicExpressionGrammar
_ao	src/arithmetic_expression_grammar.py	/^    def _ao(self):$/;"	m	class:ArithmeticExpressionGrammar
_assign_number_to_constant_identifier	src/abstract_syntax_tree.py	/^    def _assign_number_to_constant_identifier(self):$/;"	m	class:AssignmentNode
_atom	src/logic_expression_grammar.py	/^    def _atom(self, ):$/;"	m	class:LogicExpressionGrammar
_atom_or_top_bottom	src/logic_expression_grammar.py	/^    def _atom_or_top_bottom(self):$/;"	m	class:LogicExpressionGrammar
_basename	src/pico_c_compiler.py	/^def _basename(fname):$/;"	f
_check_word	src/lexer.py	/^    def _check_word(self, tokentype, word):$/;"	m	class:Lexer
_clean_up_code_piece	src/code_generator.py	/^    def _clean_up_code_piece(self, code_piece):$/;"	m	class:_CodeGenerator
_comment	.vimspector.json	/^        "_comment": "args: [.\/input.picoc, .\/output.reti, -p, -v, -a]"$/;"	s	object:configurations.Debug.configuration
_comp_operator_assignment_bitshift	src/lexer.py	/^    def _comp_operator_assignment_bitshift(self):$/;"	m	class:Lexer
_compile	src/pico_c_compiler.py	/^def _compile(fname, code):$/;"	f
_consume_next_token	src/parser_.py	/^    def _consume_next_token(self):$/;"	m	class:BacktrackingParser
_division_sign_or_comment	src/lexer.py	/^    def _division_sign_or_comment(self, ):$/;"	m	class:Lexer
_do_while	src/loop_grammar.py	/^def _do_while(self):$/;"	f
_error_message_header	src/errors.py	/^    def _error_message_header(self, error):$/;"	m	class:ErrorHandler
_fill	src/parser_.py	/^    def _fill(self, not_filled_up):$/;"	m	class:BacktrackingParser
_get_childtoken	src/abstract_syntax_tree.py	/^    def _get_childtoken(self, idx):$/;"	m	class:AllocationNode
_get_childvalue	src/abstract_syntax_tree.py	/^    def _get_childvalue(self, idx):$/;"	m	class:AllocationNode
_get_identifier_name	src/abstract_syntax_tree.py	/^    def _get_identifier_name(self):$/;"	m	class:AssignmentNode
_identifier	src/arithmetic_expression_grammar.py	/^    def _identifier(self, ):$/;"	m	class:ArithmeticExpressionGrammar
_identifier	src/lexer.py	/^    def _identifier(self):$/;"	m	class:Lexer
_identifier_special_keyword	src/lexer.py	/^    def _identifier_special_keyword(self):$/;"	m	class:Lexer
_if	src/if_else_grammar.py	/^def _if(self):$/;"	f
_if_else	src/if_else_grammar.py	/^def _if_else(self, ):$/;"	f
_if_without_else	src/if_else_grammar.py	/^def _if_without_else(self, ):$/;"	f
_instance	src/code_generator.py	/^    _instance = None$/;"	v	class:_CodeGenerator
_instance	src/symbol_table.py	/^    _instance = None$/;"	v	class:_SymbolTable
_is_assignment_allocation	src/statement_sequence_grammar.py	/^    def _is_assignment_allocation(self):$/;"	m	class:StatementSequenceGrammar
_is_constant_identifier_on_left_side	src/abstract_syntax_tree.py	/^    def _is_constant_identifier_on_left_side(self, ):$/;"	m	class:AssignmentNode
_is_last_assignment	src/abstract_syntax_tree.py	/^    def _is_last_assignment(self, ):$/;"	m	class:AssignmentNode
_is_loop	src/statement_sequence_grammar.py	/^    def _is_loop(self, ):$/;"	m	class:StatementSequenceGrammar
_is_single_value_on_right_side	src/abstract_syntax_tree.py	/^    def _is_single_value_on_right_side(self, ):$/;"	m	class:AssignmentNode
_is_statement	src/statement_sequence_grammar.py	/^    def _is_statement(self):$/;"	m	class:StatementSequenceGrammar
_is_tokennode	src/abstract_syntax_tree.py	/^    def _is_tokennode(self, node):$/;"	m	class:ASTNode
_lo	src/logic_expression_grammar.py	/^    def _lo(self):$/;"	m	class:LogicExpressionGrammar
_loop	src/loop_grammar.py	/^def _loop(self):$/;"	f
_main_function	src/function_grammar.py	/^    def _main_function(self, ):$/;"	m	class:FunctionGrammar
_mark	src/parser_.py	/^    def _mark(self):$/;"	m	class:BacktrackingParser
_not	src/lexer.py	/^    def _not(self, ):$/;"	m	class:Lexer
_not_expr	src/logic_expression_grammar.py	/^    def _not_expr(self):$/;"	m	class:LogicExpressionGrammar
_number	src/arithmetic_expression_grammar.py	/^    def _number(self, ):$/;"	m	class:ArithmeticExpressionGrammar
_number	src/lexer.py	/^    def _number(self):$/;"	m	class:Lexer
_or	src/lexer.py	/^    def _or(self):$/;"	m	class:Lexer
_or_expr	src/logic_expression_grammar.py	/^    def _or_expr(self):$/;"	m	class:LogicExpressionGrammar
_paren_arith	src/arithmetic_expression_grammar.py	/^    def _paren_arith(self):$/;"	m	class:ArithmeticExpressionGrammar
_paren_logic	src/logic_expression_grammar.py	/^    def _paren_logic(self):$/;"	m	class:LogicExpressionGrammar
_point_at_error	src/errors.py	/^    def _point_at_error(self, error):$/;"	m	class:ErrorHandler
_prec1	src/arithmetic_expression_grammar.py	/^    def _prec1(self):$/;"	m	class:ArithmeticExpressionGrammar
_prec2	src/arithmetic_expression_grammar.py	/^    def _prec2(self):$/;"	m	class:ArithmeticExpressionGrammar
_read_file	src/pico_c_compiler.py	/^def _read_file(infile, outfile):$/;"	f
_release	src/parser_.py	/^    def _release(self):$/;"	m	class:BacktrackingParser
_s	src/statement_sequence_grammar.py	/^    def _s(self):$/;"	m	class:StatementSequenceGrammar
_shell	src/pico_c_compiler.py	/^def _shell():$/;"	f
_ss	src/statement_sequence_grammar.py	/^    def _ss(self):$/;"	m	class:StatementSequenceGrammar
_sync	src/parser_.py	/^    def _sync(self, i):$/;"	m	class:BacktrackingParser
_taste_consume_ae	src/logic_expression_grammar.py	/^    def _taste_consume_ae(self):$/;"	m	class:LogicExpressionGrammar
_taste_consume_if_without_else	src/if_else_grammar.py	/^def _taste_consume_if_without_else(self):$/;"	f
_taste_consume_le	src/logic_expression_grammar.py	/^    def _taste_consume_le(self):$/;"	m	class:LogicExpressionGrammar
_top_bottom	src/logic_expression_grammar.py	/^    def _top_bottom(self, ):$/;"	m	class:LogicExpressionGrammar
_unop	src/arithmetic_expression_grammar.py	/^    def _unop(self):$/;"	m	class:ArithmeticExpressionGrammar
_while	src/loop_grammar.py	/^def _while(self):$/;"	f
adapter	.vimspector.json	/^      "adapter": "debugpy",$/;"	s	object:configurations.Debug
addChild	src/abstract_syntax_tree.py	/^    def addChild(self, node):$/;"	m	class:ASTNode
addChild	src/abstract_syntax_tree.py	/^    def addChild(self, node):$/;"	m	class:DoWhileNode
addChild	src/ast_builder.py	/^    def addChild(self, node):$/;"	m	class:ASTBuilder
add_code	src/code_generator.py	/^    def add_code(self, code, loc):$/;"	m	class:_CodeGenerator
add_marker	src/code_generator.py	/^    def add_marker(self, ):$/;"	m	class:_CodeGenerator
all	Makefile	/^all: run-shell-compile clean$/;"	t
all_loc	src/abstract_syntax_tree.py	/^    all_loc = 1$/;"	v	class:ArithmeticVariableConstantNode
allocate	src/symbol_table.py	/^    def allocate(self, sym):$/;"	m	class:_SymbolTable
args	.misc/pico_c_compiler	/^args = None$/;"	v
args	src/globals.py	/^args = None$/;"	v
assign_more	src/abstract_syntax_tree.py	/^    assign_more = "STORE ACC var_address;  # Wert von e in Adresse a speichern\\n"$/;"	v	class:AssignmentNode
assign_more_loc	src/abstract_syntax_tree.py	/^    assign_more_loc = 1$/;"	v	class:AssignmentNode
assignment	src/abstract_syntax_tree.py	/^    assignment = """# codeaa(e) (oder codela(e), falls logischer Ausdruck)$/;"	v	class:AssignmentNode
assignment_loc	src/abstract_syntax_tree.py	/^    assignment_loc = 2$/;"	v	class:AssignmentNode
basename	.misc/pico_c_compiler	/^def basename(fname):$/;"	f
bitwise_negation	src/abstract_syntax_tree.py	/^    bitwise_negation = "SUBI ACC 1; # transform negation to complement\\n"$/;"	v	class:ArithmeticUnaryOperationNode
bitwise_negation_loc	src/abstract_syntax_tree.py	/^    bitwise_negation_loc = 1$/;"	v	class:ArithmeticUnaryOperationNode
clean	Makefile	/^clean:$/;"	t
code	test/grammar_test.py	/^    code = """SUBI SP 1;$/;"	v	class:TestCodeGenerator
code_aa	src/assignment_allocation_grammar.py	/^    def code_aa(self):$/;"	m	class:AssignmentAllocationGrammar
code_ae	.misc/test_errors	/^    code_ae = ["2 + "]$/;"	v	class:TestErrors
code_ae	src/arithmetic_expression_grammar.py	/^    def code_ae(self):$/;"	m	class:ArithmeticExpressionGrammar
code_ae_le	src/logic_expression_grammar.py	/^    def code_ae_le(self):$/;"	m	class:LogicExpressionGrammar
code_f	src/function_grammar.py	/^    def code_f(self):$/;"	m	class:FunctionGrammar
code_ie	src/if_else_grammar.py	/^def code_ie(self, ):$/;"	f
code_if_if_else	src/if_else_grammar.py	/^def code_if_if_else(self):$/;"	f
code_le	src/logic_expression_grammar.py	/^    def code_le(self):$/;"	m	class:LogicExpressionGrammar
code_lo	src/loop_grammar.py	/^def code_lo(self):$/;"	f
code_ss	src/statement_sequence_grammar.py	/^    def code_ss(self):$/;"	m	class:StatementSequenceGrammar
compile	.misc/pico_c_compiler	/^def compile(fname, code):$/;"	f
condition_check	src/abstract_syntax_tree.py	/^    condition_check = """# code(af)$/;"	v	class:DoWhileNode
condition_check	src/abstract_syntax_tree.py	/^    condition_check = """# codela(l)$/;"	v	class:WhileNode
condition_check_loc	src/abstract_syntax_tree.py	/^    condition_check_loc = 3$/;"	v	class:DoWhileNode
condition_check_loc	src/abstract_syntax_tree.py	/^    condition_check_loc = 3$/;"	v	class:WhileNode
configuration	.vimspector.json	/^      "configuration": {$/;"	o	object:configurations.Debug
configurations	.vimspector.json	/^  "configurations": {$/;"	o
console	.vimspector.json	/^        "console": "externalTerminal",$/;"	s	object:configurations.Debug.configuration
constant	src/abstract_syntax_tree.py	/^    constant = "LOADI ACC encode(w);\\n"$/;"	v	class:ArithmeticVariableConstantNode
constant_identifier	src/abstract_syntax_tree.py	/^    constant_identifier = "LOADI ACC encode(c);\\n"$/;"	v	class:ArithmeticVariableConstantNode
cwd	.vimspector.json	/^        "cwd": "${workspaceFolder}",$/;"	s	object:configurations.Debug.configuration
debugOptions	.vimspector.json	/^        "debugOptions": [],$/;"	a	object:configurations.Debug.configuration
define	src/symbol_table.py	/^    def define(self, sym):$/;"	m	class:Scope
down	src/ast_builder.py	/^    def down(self, classname, tokens):$/;"	m	class:ASTBuilder
end	src/abstract_syntax_tree.py	/^    end = """# code(af)$/;"	v	class:MainFunctionNode
end	src/abstract_syntax_tree.py	/^    end = """# codeaa(e)$/;"	v	class:LogicTopBottomNode
end	src/abstract_syntax_tree.py	/^    end = """# codeaa(e1)$/;"	v	class:ArithmeticBinaryOperationNode
end	src/abstract_syntax_tree.py	/^    end = """# codeaa(e1)$/;"	v	class:LogicAtomNode
end	src/abstract_syntax_tree.py	/^    end = """# codela(l1)$/;"	v	class:LogicAndOrNode
end	src/abstract_syntax_tree.py	/^    end = """# codela(l1)$/;"	v	class:LogicNotNode
end	src/abstract_syntax_tree.py	/^    end = """# zurück zur Auswertung von l$/;"	v	class:WhileNode
end	src/abstract_syntax_tree.py	/^    end = "STOREIN SP ACC 1; # Ergebnis in oberste Stack-Zelle"$/;"	v	class:ArithmeticUnaryOperationNode
end	src/abstract_syntax_tree.py	/^    end = "STOREIN SP ACC 1;\\n"$/;"	v	class:ArithmeticVariableConstantNode
end_loc	src/abstract_syntax_tree.py	/^    end_loc = 1$/;"	v	class:ArithmeticUnaryOperationNode
end_loc	src/abstract_syntax_tree.py	/^    end_loc = 1$/;"	v	class:MainFunctionNode
end_loc	src/abstract_syntax_tree.py	/^    end_loc = 1$/;"	v	class:WhileNode
end_loc	src/abstract_syntax_tree.py	/^    end_loc = 4$/;"	v	class:LogicNotNode
end_loc	src/abstract_syntax_tree.py	/^    end_loc = 4$/;"	v	class:LogicTopBottomNode
end_loc	src/abstract_syntax_tree.py	/^    end_loc = 5$/;"	v	class:ArithmeticBinaryOperationNode
end_loc	src/abstract_syntax_tree.py	/^    end_loc = 5$/;"	v	class:LogicAndOrNode
end_loc	src/abstract_syntax_tree.py	/^    end_loc = 9$/;"	v	class:LogicAtomNode
error	.misc/test_errors	/^    syntax_tree_rootnode, error = parser.parse()$/;"	v	class:TestErrors
error	.misc/test_errors	/^    tokens, error = lexer.create_tokens()$/;"	v	class:TestErrors
expected_output	.misc/test_errors	/^    expected_output = "(CONSTANT:12, ['BINOP', 'PRECEDENCE_1']:*, (CONSTANT:165, ['BINOP', 'PREC/;"	v	class:TestErrors
getNodeType	src/abstract_syntax_tree.py	/^    def getNodeType(self):$/;"	m	class:TokenNode
get_enclosing_scope	src/symbol_table.py	/^    def get_enclosing_scope(self, ):$/;"	m	class:Scope
get_marker_loc	src/code_generator.py	/^    def get_marker_loc(self, ):$/;"	m	class:_CodeGenerator
get_name	src/symbol_table.py	/^    def get_name(self, ):$/;"	m	class:Symbol
get_scope_name	src/symbol_table.py	/^    def get_scope_name(self, ):$/;"	m	class:Scope
grammar	test/grammar_test.py	/^    grammar = None$/;"	v	class:UsefullTools
handle	src/errors.py	/^    def handle(self, function):$/;"	m	class:ErrorHandler
initTypeSystem	src/symbol_table.py	/^    def initTypeSystem(self, ):$/;"	m	class:_SymbolTable
isEmpty	src/abstract_syntax_tree.py	/^    def isEmpty(self):$/;"	m	class:TokenNode
is_tasting	src/globals.py	/^is_tasting = 0$/;"	v
justMyCode	.vimspector.json	/^        "justMyCode": true,$/;"	b	object:configurations.Debug.configuration
lexer	.misc/test_errors	/^    lexer = Lexer("<testin>", code_ae)$/;"	v	class:TestErrors
lexer	test/grammar_test.py	/^    lexer = None$/;"	v	class:UsefullTools
main	.misc/pico_c_compiler	/^def main():$/;"	f
main	.misc/test.cpp	/^int main() {$/;"	f	typeref:typename:int
main	src/pico_c_compiler.py	/^def main():$/;"	f
match	src/parser_.py	/^    def match(self, tts):$/;"	m	class:BacktrackingParser
match_and_add	src/parser_.py	/^    def match_and_add(self, tts):$/;"	m	class:BacktrackingParser
middle	src/abstract_syntax_tree.py	/^    middle = """JUMP codelength(af2) + 1;$/;"	v	class:IfElseNode
middle_loc	src/abstract_syntax_tree.py	/^    middle_loc = 1$/;"	v	class:IfElseNode
name	.vimspector.json	/^        "name": "Debug",$/;"	s	object:configurations.Debug.configuration
next_char	src/lexer.py	/^    def next_char(self):$/;"	m	class:Lexer
next_token	src/lexer.py	/^    def next_token(self):$/;"	m	class:Lexer
parser	.misc/test_errors	/^    parser = Parser(tokens)$/;"	v	class:TestErrors
program	.vimspector.json	/^        "program": "${workspaceFolder}\/test\/grammar_test.py",$/;"	s	object:configurations.Debug.configuration
project_opened	.vim/.ropeproject/config.py	/^def project_opened(project):$/;"	f
python	.vimspector.json	/^        "python": "\/usr\/bin\/python",$/;"	s	object:configurations.Debug.configuration
python.linting.enabled	.vim/coc-settings.json	/^  "python.linting.enabled": true,$/;"	b
python.linting.flake8Enabled	.vim/coc-settings.json	/^  "python.linting.flake8Enabled": true$/;"	b
python.linting.pylintEnabled	.vim/coc-settings.json	/^  "python.linting.pylintEnabled": false,$/;"	b
read_file	.misc/pico_c_compiler	/^def read_file(infile, outfile):$/;"	f
remove_marker	src/code_generator.py	/^    def remove_marker(self, ):$/;"	m	class:_CodeGenerator
replace_code_after	src/code_generator.py	/^    def replace_code_after(self, pattern, word):$/;"	m	class:_CodeGenerator
replace_code_pre	src/code_generator.py	/^    def replace_code_pre(self, code_as_ref, pattern, word):$/;"	m	class:_CodeGenerator
request	.vimspector.json	/^        "request": "launch",$/;"	s	object:configurations.Debug.configuration
resolve	src/symbol_table.py	/^    def resolve(self, name):$/;"	m	class:Scope
reveal_ast	src/grammar.py	/^    def reveal_ast(self):$/;"	m	class:Grammar
run-read-ast	Makefile	/^run-read-ast:$/;"	t
run-read-ast-verbose	Makefile	/^run-read-ast-verbose:$/;"	t
run-read-compile	Makefile	/^run-read-compile:$/;"	t
run-read-compile-comments	Makefile	/^run-read-compile-comments:$/;"	t
run-read-tokens	Makefile	/^run-read-tokens:$/;"	t
run-shell-ast	Makefile	/^run-shell-ast:$/;"	t
run-shell-ast-verbose	Makefile	/^run-shell-ast-verbose:$/;"	t
run-shell-compile	Makefile	/^run-shell-compile:$/;"	t
run-shell-compile-comments	Makefile	/^run-shell-compile-comments:$/;"	t
run-shell-tokens	Makefile	/^run-shell-tokens:$/;"	t
s:l	Session.vim	/^let s:l = 1 - ((0 * winheight(0) + 21) \/ 43)$/;"	v
s:l	Session.vim	/^let s:l = 89 - ((42 * winheight(0) + 21) \/ 43)$/;"	v
s:l	test/Session.vim	/^let s:l = 50 - ((19 * winheight(0) + 20) \/ 41)$/;"	v
s:l	test/Session.vim	/^let s:l = 58 - ((39 * winheight(0) + 20) \/ 41)$/;"	v
s:save_splitbelow	Session.vim	/^let s:save_splitbelow = &splitbelow$/;"	v
s:save_splitbelow	test/Session.vim	/^let s:save_splitbelow = &splitbelow$/;"	v
s:save_splitright	Session.vim	/^let s:save_splitright = &splitright$/;"	v
s:save_splitright	test/Session.vim	/^let s:save_splitright = &splitright$/;"	v
s:save_winminheight	Session.vim	/^let s:save_winminheight = &winminheight$/;"	v
s:save_winminheight	test/Session.vim	/^let s:save_winminheight = &winminheight$/;"	v
s:save_winminwidth	Session.vim	/^let s:save_winminwidth = &winminwidth$/;"	v
s:save_winminwidth	test/Session.vim	/^let s:save_winminwidth = &winminwidth$/;"	v
s:so_save	Session.vim	/^let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1$/;"	v
s:so_save	test/Session.vim	/^let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:sx	test/Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
s:wipebuf	test/Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
set_everything_up_for_ast	test/grammar_test.py	/^    def set_everything_up_for_ast(self, test_name, code):$/;"	m	class:UsefullTools
set_everything_up_for_ast_multiline	test/grammar_test.py	/^    def set_everything_up_for_ast_multiline(self, test_name, code_without_cr):$/;"	m	class:UsefullTools
set_everything_up_for_lexer	test/grammar_test.py	/^    def set_everything_up_for_lexer(self, test_name, code):$/;"	m	class:UsefullTools
set_everything_up_for_multiline_program	test/grammar_test.py	/^    def set_everything_up_for_multiline_program(self, test_name, input_string):$/;"	m	class:UsefullTools
set_everything_up_for_testing_program_file	test/grammar_test.py	/^    def set_everything_up_for_testing_program_file(self, test_name, programpath):$/;"	m	class:UsefullTools
set_everything_up_for_visit_multiline	test/grammar_test.py	/^    def set_everything_up_for_visit_multiline(self, test_name, code_without_cr):$/;"	m	class:UsefullTools
set_prefs	.vim/.ropeproject/config.py	/^def set_prefs(prefs):$/;"	f
shell	.misc/pico_c_compiler	/^def shell():$/;"	f
show_code	src/code_generator.py	/^    def show_code(self, ):$/;"	m	class:_CodeGenerator
show_generated_code	src/abstract_syntax_tree.py	/^    def show_generated_code(self, ):$/;"	m	class:ASTNode
start	src/abstract_syntax_tree.py	/^    start = """# codeaa(e1)$/;"	v	class:ArithmeticUnaryOperationNode
start	src/abstract_syntax_tree.py	/^    start = """# codela(l)$/;"	v	class:IfElseNode
start	src/abstract_syntax_tree.py	/^    start = """# codela(l)$/;"	v	class:IfNode
start	src/abstract_syntax_tree.py	/^    start = """LOADI SP eds;$/;"	v	class:MainFunctionNode
start	src/abstract_syntax_tree.py	/^    start = "SUBI SP 1;\\n"$/;"	v	class:ArithmeticVariableConstantNode
start_loc	src/abstract_syntax_tree.py	/^    start_loc = 1$/;"	v	class:MainFunctionNode
start_loc	src/abstract_syntax_tree.py	/^    start_loc = 3$/;"	v	class:ArithmeticUnaryOperationNode
start_loc	src/abstract_syntax_tree.py	/^    start_loc = 3$/;"	v	class:IfElseNode
start_loc	src/abstract_syntax_tree.py	/^    start_loc = 3$/;"	v	class:IfNode
start_parse	src/grammar.py	/^    def start_parse(self):$/;"	m	class:Grammar
stopOnEntry	.vimspector.json	/^        "stopOnEntry": true,$/;"	b	object:configurations.Debug.configuration
strip_multiline_string	src/abstract_syntax_tree.py	/^def strip_multiline_string(mutline_string):$/;"	f
syntax_tree_rootnode	.misc/test_errors	/^    syntax_tree_rootnode, error = parser.parse()$/;"	v	class:TestErrors
taste	src/parser_.py	/^    def taste(self, rule):$/;"	m	class:BacktrackingParser
test	Makefile	/^test:$/;"	t
test_basic_arithmetic_expression	test/grammar_test.py	/^    def test_basic_arithmetic_expression(self):$/;"	m	class:TestArithmeticExpressionGrammar
test_code_replacment_after	test/grammar_test.py	/^    def test_code_replacment_after(self, ):$/;"	m	class:TestCodeGenerator
test_comments	test/grammar_test.py	/^    def test_comments(self, ):$/;"	m	class:TestLexer
test_connected_logic_expression	test/grammar_test.py	/^    def test_connected_logic_expression(self):$/;"	m	class:TestLogicExpressionGrammar
test_const_allocation	test/grammar_test.py	/^    def test_const_allocation(self, ):$/;"	m	class:TestAssignmentGrammar
test_constant_initialisation	test/grammar_test.py	/^    def test_constant_initialisation(self, ):$/;"	m	class:TestCodeGenerator
test_do_while_loop	test/grammar_test.py	/^    def test_do_while_loop(self, ):$/;"	m	class:TestLoopGrammar
test_else_if	test/grammar_test.py	/^    def test_else_if(self, ):$/;"	m	class:TestIfElseGrammar
test_gcd	test/grammar_test.py	/^    def test_gcd(self, ):$/;"	m	class:TestPrograms
test_if_arithmetic_expression_as_logical_expression	test/grammar_test.py	/^    def test_if_arithmetic_expression_as_logical_expression(self, ):$/;"	m	class:TestIfElseGrammar
test_if_else_braces	test/grammar_test.py	/^    def test_if_else_braces(self):$/;"	m	class:TestIfElseGrammar
test_if_else_grammar	test/grammar_test.py	/^    def test_if_else_grammar(self):$/;"	m	class:TestIfElseGrammar
test_illegal_char_error	.misc/test_errors	/^    def test_illegal_char_error()$/;"	m	class:TestErrors
test_logic_and_arithmetic_parenthesis_mixed	test/grammar_test.py	/^    def test_logic_and_arithmetic_parenthesis_mixed(self, ):$/;"	m	class:TestLogicExpressionGrammar
test_logic_expression	test/grammar_test.py	/^    def test_logic_expression(self):$/;"	m	class:TestLogicExpressionGrammar
test_logic_precedence_1	test/grammar_test.py	/^    def test_logic_precedence_1(self, ):$/;"	m	class:TestLogicExpressionGrammar
test_logic_precedence_2	test/grammar_test.py	/^    def test_logic_precedence_2(self, ):$/;"	m	class:TestLogicExpressionGrammar
test_loop_and_nested_if_else	test/grammar_test.py	/^    def test_loop_and_nested_if_else(self, ):$/;"	m	class:TestLoopGrammar
test_loop_statements_after_another	test/grammar_test.py	/^    def test_loop_statements_after_another(self, ):$/;"	m	class:TestLoopGrammar
test_mixed_if_else_after_another	test/grammar_test.py	/^    def test_mixed_if_else_after_another(self, ):$/;"	m	class:TestIfElseGrammar
test_name	src/globals.py	/^test_name = ""$/;"	v
test_negative_parenthesis_and_variable	test/grammar_test.py	/^    def test_negative_parenthesis_and_variable(self):$/;"	m	class:TestArithmeticExpressionGrammar
test_nested_loops	test/grammar_test.py	/^    def test_nested_loops(self, ):$/;"	m	class:TestLoopGrammar
test_no_semicolon	test/grammar_test.py	/^    def test_no_semicolon(self, ):$/;"	m	class:TestError
test_numbers	test/grammar_test.py	/^    def test_numbers(self, ):$/;"	m	class:TestLexer
test_parenthesis	.misc/test_parser	/^    def test_parenthesis(self):$/;"	m	class:TestArithmeticExpreessions
test_parenthesis	test/grammar_test.py	/^    def test_parenthesis(self):$/;"	m	class:TestArithmeticExpressionGrammar
test_precedence_1	test/grammar_test.py	/^    def test_precedence_1(self):$/;"	m	class:TestArithmeticExpressionGrammar
test_precedence_2	test/grammar_test.py	/^    def test_precedence_2(self):$/;"	m	class:TestArithmeticExpressionGrammar
test_precedence_3	test/grammar_test.py	/^    def test_precedence_3(self):$/;"	m	class:TestArithmeticExpressionGrammar
test_precedence_rules	.misc/test_parser	/^    def test_precedence_rules(self):$/;"	m	class:TestArithmeticExpreessions
test_several_statements_loop	test/grammar_test.py	/^    def test_several_statements_loop(self, ):$/;"	m	class:TestLoopGrammar
test_single_line_comment	test/grammar_test.py	/^    def test_single_line_comment(self, ):$/;"	m	class:TestComments
test_space_and_word_seperation	test/grammar_test.py	/^    def test_space_and_word_seperation(self, ):$/;"	m	class:TestLexer
test_two_if_after_another	test/grammar_test.py	/^    def test_two_if_after_another(self, ):$/;"	m	class:TestIfElseGrammar
test_unary_operators	test/grammar_test.py	/^    def test_unary_operators(self):$/;"	m	class:TestArithmeticExpressionGrammar
test_unop	.misc/test_parser	/^    def test_unop(self):$/;"	m	class:TestArithmeticExpreessions
test_varying_spacing	.misc/test_parser	/^    def test_varying_spacing(self):$/;"	m	class:TestArithmeticExpreessions
test_while_generation	test/grammar_test.py	/^    def test_while_generation(self, ):$/;"	m	class:TestCodeGenerator
test_while_loop	test/grammar_test.py	/^    def test_while_loop(self, ):$/;"	m	class:TestLoopGrammar
tokens	.misc/test_errors	/^    tokens, error = lexer.create_tokens()$/;"	v	class:TestErrors
type	.vimspector.json	/^        "type": "python",$/;"	s	object:configurations.Debug.configuration
up	src/ast_builder.py	/^    def up(self, savestate_node):$/;"	m	class:ASTBuilder
variable_identifier	src/abstract_syntax_tree.py	/^    variable_identifier = "LOAD ACC var_identifier;\\n"$/;"	v	class:ArithmeticVariableConstantNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:AllocationNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:ArithmeticBinaryOperationNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:ArithmeticUnaryOperationNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:ArithmeticVariableConstantNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:AssignmentNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:DoWhileNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:IfElseNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:IfNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:LogicAndOrNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:LogicAtomNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:LogicNotNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:LogicTopBottomNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:MainFunctionNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:TokenNode
visit	src/abstract_syntax_tree.py	/^    def visit(self, ):$/;"	m	class:WhileNode
